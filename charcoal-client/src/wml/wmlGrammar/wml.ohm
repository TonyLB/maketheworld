WorldMarkupLangage {

    //
    // This section defines the tags that make up the WML language
    //

    WMLFileContents = AssetExpression
            | StoryExpression
            | CharacterExpression

    CharacterExpression = TagExpression<"Character", "key", ("player" | "fileName" | "zone" | "subFolder"), none, none, CharacterLegalContents, none>
    CharacterLegalContents = ImageExpression
            | LiteralNameExpression
            | PronounsExpression
            | LiteralValueTag<"OneCoolThing">
            | LiteralValueTag<"Outfit">
            | LiteralValueTag<"FirstImpression">

    PronounsExpression = TagExpression<"Pronouns", none, ("subject" | "object" | "possessive" | "adjective" | "reflexive"), none, none, none, none>
            | TagSelfClosing<"Pronouns", none, ("subject" | "object" | "possessive" | "adjective" | "reflexive"), none, none, none>

    StoryExpression = TagExpression<"Story", "key", ("fileName" | "zone" | "subFolder" | "player"), none, "instance", AssetLegalContents, none>

    AssetExpression = TagExpression<"Asset", "key", ("fileName" | "zone" | "subFolder" | "player"), none, none, AssetLegalContents, none>
    AssetLegalContents = ImportExpression
            | VariableExpression
            | ComputedExpression
            | ActionExpression
            | LayerExpression
            | ConditionExpression
            | MapExpression
            | RoomExpression
            | ExitExpression
            | FeatureExpression
            | LiteralNameExpression
            | string

    MapExpression = TagExpression<"Map", "key", none, none, none, MapLegalContents, none>
    MapLegalContents = MapRoomExpression
            | NameExpression
            | ImageExpression

    ImageExpression = TagExpression<"Image", "key", "fileURL", none, none, none, none>
            | TagSelfClosing<"Image", "key", "fileURL", none, none, none>

    ImportExpression = TagExpression<"Import", "from", none, none, none, ImportLegalContents, none>
    ImportLegalContents = UseExpression

    UseExpression = TagExpression<"Use", ("key" | "as"), "type", none, none, none, none>
            | TagSelfClosing<"Use", ("key" | "as"), "type", none, none, none>

    DependencyExpression = TagExpression<"Depend", "on", none, none, none, none, none>
            | TagSelfClosing<"Depend", "on", none, none, none, none>

    VariableExpression = TagExpression<"Variable", "key", none, "default", none, none, none>
            | TagSelfClosing<"Variable", "key", none, "default", none, none>

    ComputedExpression = TagExpression<"Computed", "key", none, "src", none, DependencyExpression, none>
            | TagSelfClosing<"Computed", "key", none, "src", none, none>

    ActionExpression = TagExpression<"Action", "key", none, "src", none, none, none>
            | TagSelfClosing<"Action", "key", none, "src", none, none>

    ConditionExpression = TagExpression<"Condition", none, none, "if", none, ConditionLegalContents, none>
    ConditionLegalContents = RoomExpression
            | MapExpression
            | ConditionExpression
            | TextContents
            | LayerExpression
            | ExitExpression
            | FeatureExpression
            | DependencyExpression

    LayerExpression = TagExpression<"Layer", "key", none, none, none, LayerLegalContents, none>
    LayerLegalContents = RoomExpression
            | ConditionExpression
            | ExitExpression

    ExitExpression = TagExpression<"Exit", ("key" | "to" | "from"), none, none, none, string, none>
            | TagSelfClosing<"Exit", ("key" | "to" | "from"), none, none, none, none>

    LinkExpression = TagExpression<"Link", "to", none, none, none, string, spaceCompressor>

    MapRoomExpression = TagExpression<"Room", "key", ("display" | "x" | "y"), none, "global", RoomContents, none>
            | TagSelfClosing<"Room", "key", ("display" | "x" | "y"), none, "global", none>
    RoomExpression = TagExpression<"Room", "key", none, none, "global", RoomContents, none>
            | TagSelfClosing<"Room", "key", "display", none, "global", none>
    RoomContents = DescriptionExpression
            | NameExpression
            | ExitExpression
            | FeatureExpression

    FeatureExpression = TagExpression<"Feature", "key", none, none, "global", FeatureContents, none>
            | TagSelfClosing<"Feature", "key", "display", none, "global", none>
    FeatureContents = DescriptionExpression
            | NameExpression

    DescriptionExpression = TagExpression<"Description", none, "display", none, ("spaceBefore" | "spaceAfter"), DescriptionContents, none>
    DescriptionContents = DescriptionTextContents
            | LinkExpression
            | LineBreakExpression

    LineBreakExpression = "<br" "/>"

    LiteralNameExpression = LiteralValueTag<"Name">
    NameExpression = TagExpression<"Name", none, none, none, ("spaceBefore" | "spaceAfter"), TextContents, none>

    LiteralValueTag<label> = TagExpression<label, none, none, none, none, string, none>

    ValueTag<label> = TagExpression<label, none, none, none, none, TextContents, none>
    DescriptionTextContents = string
    TextContents = string | embeddedJSExpression

    //
    // The following define the ways in which tags can be structured
    //

    TagExpression<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs, LegalContents, endSpace> = TagOpen<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> LegalContents* tagClose<tag> #(endSpace)?
    string = (stringText | spaceCompressor)+
    stringText = (~("<" | "{" | space) any | "\\<" | "\\{")+
    legalKey = letter (letter | digit | "_")+
    spaceCompressor = (space)+
    TagSelfClosing<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs, endSpace> = "<" tag TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* "/>" #(endSpace)?
    TagOpen<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = "<" tag TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* ">"
    TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = TagArgumentKey<tagKeyArgs> | TagLiteralArgument<tagLiteralArgs> | TagProgramArgument<tagProgramArgs> | tagBooleanArgument<tagBooleanArgs>
    TagLiteralArgument<tagLiteralArgs> = tagArgumentQuoted<tagLiteralArgs>
    TagProgramArgument<tagProgramArgs> = tagArgumentQuoted<tagProgramArgs> | tagArgumentBracketed<tagProgramArgs>
    tagBooleanArgument<tagBooleanArgs> = tagBooleanArgs &(space | ">" | "/>")
    tagArgumentQuoted<tagLegalArgs> = tagLegalArgs "=\"" tagArgValueQuoted
    TagArgumentKey<tagLegalArgs> = #(tagLegalArgs "=(") legalKey ")"
    tagArgumentBracketed<tagLegalArgs> = tagLegalArgs "={" jsExpression* "}"
    tagArgValueQuoted = ("\\\"" | ~"\"" any)* "\""
    tagClose<tag> = "</" tag ">"
    none = ~">" ">"

    //
    // embeddedJSExpression parses from the starting open bracket through to the
    //   *MATCHING* close bracket, using a subset of JS syntax that concentrates
    //   on all the ways that JS could let you mess up that matching (quotes,
    //   nesting, and template literals figuring high on the list)
    //
    // While we could, technically, validate the entire ES5 JS Syntax (after all,
    // Ohm publishes their schema), it wouldn't gain us any value here, and it
    // has a quite noticeable resource cost:  Compiling that schema and executing
    // it slows the perception Lambda function down to a crawl.  If a need for
    // such pre-processing emerges, look into how to optimize compiling and executing
    // very large Ohm schemata.
    //
    embeddedJSExpression = "{" jsExpression* "}"
    jsExpression = embeddedJSExpression
                    | jsDoubleQuotedString
                    | jsSingleQuotedString
                    | jsTemplateString
                    | jsText
    jsDoubleQuotedString = "\"" jsNoDoubleQuote* "\""
    jsNoDoubleQuote = "\\\"" | (~"\"" any)
    jsSingleQuotedString = "\'" jsNoSingleQuote* "\'"
    jsNoSingleQuote = "\\\'" | (~"\'" any)
    jsTemplateString = "`" (jsNoBackQuote | jsTemplateEvaluation )* "`"
    jsTemplateEvaluation = "${" jsExpression "}"
    jsNoBackQuote = "\\`" | (~("`" | "${") any)
    jsText = ("\\{" | "\\\"" | "\\'" | "\\`" | "\\}" | (~("{" | "\"" | "\'" | "`" | "}") any))+

    // Override Ohm's built-in definition of space.  Cribbed from es5.ohm
    space := whitespace | lineTerminator | comment

	sourceCharacter = any
    whitespace = "\t"
                | "\x0B"    -- verticalTab
                | "\x0C"    -- formFeed
                | " "
                | "\u00A0"  -- noBreakSpace
                | "\uFEFF"  -- byteOrderMark
                | unicodeSpaceSeparator

	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"

    lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
    lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"

    comment = multiLineComment | singleLineComment

    multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
    singleLineComment = "//" (~lineTerminator sourceCharacter)*

}
