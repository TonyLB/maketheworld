WorldMarkupLangage {

    //
    // This section defines the tags that make up the WML language
    //

    WMLFileContents = AssetExpression
            | CharacterExpression

    CharacterExpression = TagExpression<"Character", "key", ("player" | "fileName" | "zone" | "subFolder"), none, none, CharacterLegalContents>
    CharacterLegalContents = LiteralNameExpression
            | LiteralValueTag<"Pronouns">
            | LiteralValueTag<"OneCoolThing">
            | LiteralValueTag<"Outfit">
            | LiteralValueTag<"FirstImpression">

    AssetExpression = TagExpression<"Asset", "key", ("fileName" | "zone" | "subFolder" | "player"), none, none, AssetLegalContents>
    AssetLegalContents = ImportExpression
            | VariableExpression
            | ActionExpression
            | LayerExpression
            | ConditionExpression
            | RoomExpression
            | ExitExpression
            | LiteralNameExpression
            | string

    ImportExpression = TagExpression<"Import", "from", none, none, none, ImportLegalContents>
    ImportLegalContents = UseExpression

    UseExpression = TagExpression<"Use", ("key" | "as"), none, none, none, none>
            | TagSelfClosing<"Use", ("key" | "as"), none, none, none>

    DependencyExpression = TagExpression<"Depend", "on", none, none, none, none>
            | TagSelfClosing<"Depend", "on", none, none, none>

    VariableExpression = TagExpression<"Variable", "key", none, "default", none, none>
            | TagSelfClosing<"Variable", "key", none, "default", none>

    ActionExpression = TagExpression<"Action", "key", none, "src", none, none>
            | TagSelfClosing<"Action", "key", none, "src", none>

    ConditionExpression = TagExpression<"Condition", none, none, "if", none, ConditionLegalContents>
    ConditionLegalContents = RoomExpression
            | ConditionExpression
            | TextContents
            | LayerExpression
            | ExitExpression

    LayerExpression = TagExpression<"Layer", "key", none, none, none, LayerLegalContents>
    LayerLegalContents = RoomExpression
            | ConditionExpression
            | ExitExpression

    ExitExpression = TagExpression<"Exit", ("key" | "to" | "from"), none, none, none, string>
            | TagSelfClosing<"Exit", ("key" | "to" | "from"), none, none, none>

    LinkExpression = TagExpression<"Link", ("key" | "to"), none, none, none, string>

    RoomExpression = TagExpression<"Room", "key", "display", none, "global", RoomContents>
    RoomContents = TextContents
            | NameExpression
            | ExitExpression
            | LinkExpression

    LiteralNameExpression = LiteralValueTag<"Name">
    NameExpression = ValueTag<"Name">

    LiteralValueTag<label> = TagExpression<label, none, none, none, none, string>

    ValueTag<label> = TagExpression<label, none, none, none, none, TextContents>
    TextContents = string | EmbeddedJSExpression

    //
    // The following define the ways in which tags can be structured
    //

    TagExpression<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs, LegalContents> = TagOpen<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> LegalContents* TagClose<tag>
    string = (stringText | spaceCompressor)+
    stringText = (~("<" | "{" | space) any | "\\<" | "\\{")+
    legalKey = (letter | digit | "-" | "_")*
    spaceCompressor = (space)+
    TagSelfClosing<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = "<" tag TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* "/>"
    TagOpen<tag, tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = "<" tag TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* ">"
    TagArgument<tagKeyArgs, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = TagArgumentKey<tagKeyArgs> | TagLiteralArgument<tagLiteralArgs> | TagProgramArgument<tagProgramArgs> | tagBooleanArgument<tagBooleanArgs>
    TagLiteralArgument<tagLiteralArgs> = tagArgumentQuoted<tagLiteralArgs>
    TagProgramArgument<tagProgramArgs> = tagArgumentQuoted<tagProgramArgs> | TagArgumentBracketed<tagProgramArgs>
    tagBooleanArgument<tagBooleanArgs> = tagBooleanArgs &(space | ">" | "/>")
    tagArgumentQuoted<tagLegalArgs> = tagLegalArgs "=\"" tagArgValueQuoted
    TagArgumentKey<tagLegalArgs> = #(tagLegalArgs "=(") legalKey ")"
    TagArgumentBracketed<tagLegalArgs> = #(tagLegalArgs "={") JSExpression* "}"
    tagArgValueQuoted = ("\\\"" | ~"\"" any)* "\""
    TagClose<tag> = "</" tag ">"
    none = ~">" ">"

    //
    // EmbeddedJSExpression parses from the starting open bracket through to the
    //   *MATCHING* close bracket, using a subset of JS syntax that concentrates
    //   on all the ways that JS could let you mess up that matching (quotes,
    //   nesting, and template literals figuring high on the list)
    //
    // While we could, technically, validate the entire ES5 JS Syntax (after all,
    // Ohm publishes their schema), it wouldn't gain us any value here, and it
    // has a quite noticeable resource cost:  Compiling that schema and executing
    // it slows the perception Lambda function down to a crawl.  If a need for
    // such pre-processing emerges, look into how to optimize compiling and executing
    // very large Ohm schemata.
    //
    EmbeddedJSExpression = "{" JSExpression* "}"
    JSExpression = EmbeddedJSExpression
                    | JSDoubleQuotedString
                    | JSSingleQuotedString
                    | JSTemplateString
                    | JSText
    JSDoubleQuotedString = "\"" JSNoDoubleQuote* "\""
    JSNoDoubleQuote = "\\\"" | (~"\"" any)
    JSSingleQuotedString = "\'" JSNoSingleQuote* "\'"
    JSNoSingleQuote = "\\\'" | (~"\'" any)
    JSTemplateString = "`" (JSNoBackQuote | JSTemplateEvaluation )* "`"
    JSTemplateEvaluation = "${" JSExpression "}"
    JSNoBackQuote = "\\`" | (~("`" | "${") any)
    JSText = ("\\{" | "\\\"" | "\\'" | "\\`" | "\\}" | (~("{" | "\"" | "\'" | "`" | "}") any))+

    // Override Ohm's built-in definition of space.  Cribbed from es5.ohm
    space := whitespace | lineTerminator | comment

	sourceCharacter = any
    whitespace = "\t"
                | "\x0B"    -- verticalTab
                | "\x0C"    -- formFeed
                | " "
                | "\u00A0"  -- noBreakSpace
                | "\uFEFF"  -- byteOrderMark
                | unicodeSpaceSeparator

	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"

    lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
    lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"

    comment = multiLineComment | singleLineComment

    multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
    singleLineComment = "//" (~lineTerminator sourceCharacter)*

}
