WorldMarkupLangage {

    //
    // This section defines the tags that make up the WML language
    //

    WMLFileContents = AssetExpression
            | CharacterExpression

    CharacterExpression = TagExpression<"Character", ("key" | "player" | "fileName" | "zone" | "subFolder"), none, none, CharacterLegalContents>
    CharacterLegalContents = LiteralNameExpression
            | LiteralValueTag<"Pronouns">
            | LiteralValueTag<"OneCoolThing">
            | LiteralValueTag<"Outfit">
            | LiteralValueTag<"FirstImpression">

    AssetExpression = TagExpression<"Asset", ("key" | "fileName" | "zone" | "subFolder" | "player"), none, none, AssetLegalContents>
    AssetLegalContents = ImportExpression
            | VariableExpression
            | LayerExpression
            | ConditionExpression
            | RoomExpression
            | ExitExpression
            | LiteralNameExpression
            | string

    ImportExpression = TagExpression<"Import", ("from"), none, none, ImportLegalContents>
    ImportLegalContents = UseExpression

    UseExpression = TagExpression<"Use", ("key" | "as"), none, none, none>
            | TagSelfClosing<"Use", ("key" | "as"), none, none>

    VariableExpression = TagExpression<"Variable", "key", "default", none, none>
            | TagSelfClosing<"Variable", "key", "default", none>

    ConditionExpression = TagExpression<"Condition", none, "if", none, ConditionLegalContents>
    ConditionLegalContents = RoomExpression
            | ConditionExpression
            | TextContents
            | LayerExpression
            | ExitExpression

    LayerExpression = TagExpression<"Layer", "key", none, none, LayerLegalContents>
    LayerLegalContents = RoomExpression
            | ConditionExpression
            | ExitExpression

    ExitExpression = TagExpression<"Exit", ("key" | "to" | "from"), none, none, string>
            | TagSelfClosing<"Exit", ("key" | "to" | "from"), none, none>

    RoomExpression = TagExpression<"Room", ("key" | "display"), none, "global", RoomContents>
    RoomContents = TextContents
            | NameExpression
            | ExitExpression

    LiteralNameExpression = LiteralValueTag<"Name">
    NameExpression = ValueTag<"Name">

    LiteralValueTag<label> = TagExpression<label, none, none, none, string>

    ValueTag<label> = TagExpression<label, none, none, none, TextContents>
    TextContents = string | EmbeddedJSExpression

    //
    // The following define the ways in which tags can be structured
    //

    TagExpression<tag, tagLiteralArgs, tagProgramArgs, tagBooleanArgs, LegalContents> = TagOpen<tag, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> LegalContents* TagClose<tag>
    string = (stringText | spaceCompressor)+
    stringText = (~("<" | "{" | space) any | "\\<" | "\\{")+
    spaceCompressor = (space)+
    TagSelfClosing<tag, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = "<" tag TagArgument<tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* "/>"
    TagOpen<tag, tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = "<" tag TagArgument<tagLiteralArgs, tagProgramArgs, tagBooleanArgs>* ">"
    TagArgument<tagLiteralArgs, tagProgramArgs, tagBooleanArgs> = TagLiteralArgument<tagLiteralArgs> | TagProgramArgument<tagProgramArgs> | tagBooleanArgument<tagBooleanArgs>
    TagLiteralArgument<tagLiteralArgs> = tagArgumentQuoted<tagLiteralArgs>
    TagProgramArgument<tagProgramArgs> = tagArgumentQuoted<tagProgramArgs> | TagArgumentBracketed<tagProgramArgs>
    tagBooleanArgument<tagBooleanArgs> = tagBooleanArgs &(space | ">" | "/>")
    tagArgumentQuoted<tagLegalArgs> = tagLegalArgs "=\"" tagArgValueQuoted
    TagArgumentBracketed<tagLegalArgs> = #(tagLegalArgs "={") JSExpression* "}"
    tagArgValueQuoted = ("\\\"" | ~"\"" any)* "\""
    TagClose<tag> = "</" tag ">"
    none = ~">" ">"

    //
    // EmbeddedJSExpression parses from the starting open bracket through to the
    //   *MATCHING* close bracket, using a subset of JS syntax that concentrates
    //   on all the ways that JS could let you mess up that matching (quotes,
    //   nesting, and template literals figuring high on the list)
    //
    // While we could, technically, validate the entire ES5 JS Syntax (after all,
    // Ohm publishes their schema), it wouldn't gain us any value here, and it
    // has a quite noticeable resource cost:  Compiling that schema and executing
    // it slows the perception Lambda function down to a crawl.  If a need for
    // such pre-processing emerges, look into how to optimize compiling and executing
    // very large Ohm schemata.
    //
    EmbeddedJSExpression = "{" JSExpression* "}"
    JSExpression = EmbeddedJSExpression
                    | JSDoubleQuotedString
                    | JSSingleQuotedString
                    | JSTemplateString
                    | JSText
    JSDoubleQuotedString = "\"" JSNoDoubleQuote* "\""
    JSNoDoubleQuote = "\\\"" | (~"\"" any)
    JSSingleQuotedString = "\'" JSNoSingleQuote* "\'"
    JSNoSingleQuote = "\\\'" | (~"\'" any)
    JSTemplateString = "`" (JSNoBackQuote | JSTemplateEvaluation )* "`"
    JSTemplateEvaluation = "${" JSExpression "}"
    JSNoBackQuote = "\\`" | (~("`" | "${") any)
    JSText = ("\\{" | "\\\"" | "\\'" | "\\`" | "\\}" | (~("{" | "\"" | "\'" | "`" | "}") any))+

    // Override Ohm's built-in definition of space.  Cribbed from es5.ohm
    space := whitespace | lineTerminator | comment

	sourceCharacter = any
    whitespace = "\t"
                | "\x0B"    -- verticalTab
                | "\x0C"    -- formFeed
                | " "
                | "\u00A0"  -- noBreakSpace
                | "\uFEFF"  -- byteOrderMark
                | unicodeSpaceSeparator

	unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"

    lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
    lineTerminatorSequence = "\n" | "\r" ~"\n" | "\u2028" | "\u2029" | "\r\n"

    comment = multiLineComment | singleLineComment

    multiLineComment = "/*" (~"*/" sourceCharacter)* "*/"
    singleLineComment = "//" (~lineTerminator sourceCharacter)*

}
