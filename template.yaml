AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  burnedover-mush-app

  SAM Template for burnedover-mush, a serverless multiplayer text roleplaying system,
  with DynamoDB storage, React front-end and administrative tools.

Parameters:
  TablePrefix:
    Type: String
    Default: 'burnedover'
    Description: (Required) The name of the new DynamoDB to store connection identifiers for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'
  PermanentsStack:
    Type: String
    Default: 'BurnedOverPermanentsStack'
    Description: (Required) The name of the stack containing the permanents DynamoDB table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'

Resources:
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub ${TablePrefix}-user-UserPool
      AutoVerifiedAttributes:
        - email
      MfaConfiguration: "OFF"
      AccountRecoverySetting:
        RecoveryMechanisms:
          - Name: verified_email
            Priority: 1
      EmailVerificationSubject: Welcome to BurnedOverMUSH
      EmailVerificationMessage: >
          Thank you for signing up for BurnedOverMUSH.  Here is your verification code (the system will ask for it): {####}
      Schema:
        - Name: email
          AttributeDataType: String
          Mutable: false
          Required: true
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      ClientName: !Sub ${TablePrefix}-client
      GenerateSecret: false
      UserPoolId: !Ref UserPool
      AllowedOAuthFlows:
        - code
      AllowedOAuthFlowsUserPoolClient: true
      AllowedOAuthScopes:
        - email
        - openid
        - profile
        - aws.cognito.signin.user.admin
      ExplicitAuthFlows:
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_USER_SRP_AUTH
      CallbackURLs:
        - http://localhost:3000
  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      UserPoolId: !Ref UserPool
      Domain: !Sub ${TablePrefix}-auth
  RealTimeWebSocket:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: BurnedOverRealTimeSocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.message"
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref ConnectInteg
  ConnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Connect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnConnectFunction.Arn}/invocations
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DisconnectInteg
  DisconnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnDisconnectFunction.Arn}/invocations
  SendRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: sendmessage
      AuthorizationType: NONE
      OperationName: SendRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref SendInteg
  SendInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Send Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SendMessageFunction.Arn}/invocations
  RegisterNameRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: registername
      AuthorizationType: NONE
      OperationName: RegisterNameRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref RegisterNameInteg
  RegisterNameInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Register Name Integtration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RegisterNameFunction.Arn}/invocations
  RealTimeDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
    - ConnectRoute
    - SendRoute
    - RegisterNameRoute
    - DisconnectRoute
    Properties:
      ApiId: !Ref RealTimeWebSocket
  RealTimeStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      StageName: Prod
      Description: Prod Stage
      DeploymentId: !Ref RealTimeDeployment
      ApiId: !Ref RealTimeWebSocket
  PlayersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "connectionId"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "connectionId"
        KeyType: "HASH"
      SSESpecification:
        SSEEnabled: False
      TableName: !Sub '${TablePrefix}_players'
  CharactersInPlayTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "CharacterId"
        AttributeType: "S"
      - AttributeName: "RoomId"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "CharacterId"
        KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: RoomIndex
          KeySchema:
            - AttributeName: RoomId
              KeyType: HASH
            - AttributeName: CharacterId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      SSESpecification:
        SSEEnabled: False
      TimeToLiveSpecification:
        AttributeName: "ExpirationTime"
        Enabled: True
      TableName: !Sub '${TablePrefix}_characters_in_play'
  SharedLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: shared-layer
        Description: Lambda layer with shared code for functions
        ContentUri: lambda/shared/
        CompatibleRuntimes:
          - nodejs12.x
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: uuid-layer
        Description: Lambda layer to import the uuid library
        ContentUri: lambda/uuidLayer/
        CompatibleRuntimes:
          - nodejs12.x
  OnConnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/onconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
      Policies:
      - DynamoDBCrudPolicy:
          TableName: !Sub '${TablePrefix}_players'
      - DynamoDBReadPolicy:
          TableName: !Sub '${TablePrefix}_permanents'
  OnConnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnConnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnConnectFunction
      Principal: apigateway.amazonaws.com
  OnDisconnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/ondisconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
      Policies:
      - DynamoDBCrudPolicy:
          TableName: !Sub '${TablePrefix}_players'
      - DynamoDBReadPolicy:
          TableName: !Sub '${TablePrefix}_permanents'
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
  OnDisconnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnDisconnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnDisconnectFunction
      Principal: apigateway.amazonaws.com
  SendMessageFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/sendmessage/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
      Policies:
      - DynamoDBCrudPolicy:
          TableName: !Sub '${TablePrefix}_players'
      - DynamoDBReadPolicy:
          TableName: !Sub '${TablePrefix}_permanents'
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
  SendMessagePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - SendMessageFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref SendMessageFunction
      Principal: apigateway.amazonaws.com
  RegisterNameFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/registername/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
      - DynamoDBCrudPolicy:
          TableName: !Sub '${TablePrefix}_players'
      - DynamoDBReadPolicy:
          TableName: !Sub '${TablePrefix}_permanents'
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
      - Statement:
        - Effect: Allow
          Action: appsync:GraphQL
          Resource: !Sub '${AppSyncAPI}/*'
  RegisterNamePermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - RegisterNameFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref RegisterNameFunction
      Principal: apigateway.amazonaws.com
  AppSyncAPI:
      Type: AWS::AppSync::GraphQLApi
      Properties:
          Name: !Sub ${TablePrefix}AppSyncAPI
          AuthenticationType: AMAZON_COGNITO_USER_POOLS
          UserPoolConfig:
              AwsRegion: us-east-1
              UserPoolId: !Ref UserPool
              DefaultAction: ALLOW
          AdditionalAuthenticationProviders:
              - AuthenticationType: AWS_IAM
  AppSyncAPIExecutionRole:
      Type: AWS::IAM::Role
      Properties:
          AssumeRolePolicyDocument:
              Statement:
                - Effect: Allow
                  Principal:
                      Service: appsync.amazonaws.com
                  Action:
                      - sts:AssumeRole
          Policies:
            - PolicyName: CharactersPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters"
            - PolicyName: CharacterIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters/*"
            - PolicyName: CharactersInPlayPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play"
            - PolicyName: PermanentsPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
            - PolicyName: PermanentsIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*"
            - PolicyName: PutRoomPathsPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "lambda:InvokeFunction"
                      Resource: !GetAtt PutRoomPathsFunction.Arn
  CharacterDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: Character
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_characters
  CharactersInPlayDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: CharactersInPlay
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_characters_in_play
  PermanentsDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: Permanents
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_permanents
  QueryGetCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharacter
          DataSourceName: !GetAtt CharacterDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toDynamoDBJson($ctx.args.characterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryPlayerCharactersResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getPlayerCharacters
          DataSourceName: !GetAtt CharacterDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "PlayerName = :PlayerName",
                      "expressionValues": {
                          ":PlayerName": $util.dynamodb.toDynamoDBJson($context.identity.username)
                      }
                  },
                  "index": "PlayerAndNameIndex"
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result.items)"
  PutCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putCharacter
          DataSourceName: !GetAtt CharacterDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.qr($ctx.args.put("CharacterId", $util.autoId()))
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "CharacterId": $ddb.toStringJson($ctx.args.CharacterId)
                  },
                  "attributeValues": {
                      "PlayerName": $ddb.toStringJson($context.identity.username),
                      "Name": $ddb.toStringJson($ctx.args.Name)
                      #if($ctx.args.Pronouns), "Pronouns": $ddb.toStringJson($ctx.args.Pronouns) #end
                      #if($ctx.args.FirstImpression), "FirstImpression": $ddb.toStringJson($ctx.args.FirstImpression) #end
                      #if($ctx.args.OneCoolThing), "OneCoolThing": $ddb.toStringJson($ctx.args.OneCoolThing) #end
                      #if($ctx.args.Outfit), "Outfit": $ddb.toStringJson($ctx.args.Outfit) #end
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  CharacterInPlayGetCharacter:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: CharacterInPlay
          FieldName: Character
          DataSourceName: !GetAtt CharacterDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toDynamoDBJson($context.source.CharacterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetCharactersInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharactersInPlay
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Scan",
                  "filter": {
                      "expression": "attribute_exists(ConnectionId)",
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result.items)"
  QueryGetNeighborhoodTree:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getNeighborhoodTree
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2018-05-29",
                  "operation": "Scan",
                  "filter": {
                      "expression": "#t = :neighborhood or #t = :room",
                      "expressionNames": {
                          "#t": "type"
                      },
                      "expressionValues": {
                          ":neighborhood": $util.dynamodb.toStringJson("NEIGHBORHOOD"),
                          ":room": $util.dynamodb.toStringJson("ROOM")
                      }
                  }
              }
          ResponseMappingTemplate: >
              #set($output = [])
              #foreach($node in $ctx.result.items)
                  #if($node.type == "NEIGHBORHOOD")
                      #set($typeName = "Neighborhood")
                  #else
                      #set($typeName = "Room")
                  #end
                  $util.qr($output.add({
                      "__typename": $typeName,
                      "Name": $node.name,
                      "Type": $node.type,
                      "PermanentId": $node.permanentId,
                      "ParentId": $node.parentId,
                      "Ancestry": $node.ancestry
                  }))
              #end
              $util.toJson($output)
  QueryGetNeighborhood:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getNeighborhood
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)
                  }
              }
          ResponseMappingTemplate: >
              #if($ctx.result.type == "NEIGHBORHOOD")
                  {
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "ParentId": $util.toJson($ctx.result.parentId),
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "Name": $util.toJson($ctx.result.name),
                      "Type": $util.toJson($ctx.result.type),
                      "Ancestry": $util.toJson($ctx.result.ancestry),
                      "Description": $util.toJson($ctx.result.description)
                  }
              #else
                  $util.error("PermanentId must specify a NEIGHBORHOOD type permanent")
              #end
  QueryGetRoom:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getRoom
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toDynamoDBJson($ctx.args.PermanentId)
                  }
              }
          ResponseMappingTemplate: >
              #if($ctx.result.type == "ROOM")
                  {
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "ParentId": $util.toJson($ctx.result.parentId),
                      "PermanentId": $util.toJson($ctx.result.permanentId),
                      "Name": $util.toJson($ctx.result.name),
                      "Type": $util.toJson($ctx.result.type),
                      "Ancestry": $util.toJson($ctx.result.ancestry),
                      "Description": $util.toJson($ctx.result.description)
                  }
              #else
                  $util.error("PermanentId must specify a ROOM type permanent")
              #end
  QueryGetRoomExits:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Room
          FieldName: Exits
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "fromRoomId = :RoomId",
                      "expressionValues": {
                          ":RoomId": $util.dynamodb.toDynamoDBJson($ctx.source.PermanentId)
                      }
                  },
                  "index": "fromRoomIndex"
              }
          ResponseMappingTemplate: >
              [
                  #foreach($exit in $ctx.result.items)
                      {
                          "PermanentId": $util.toJson($exit.permanentId),
                          "Name": $util.toJson($exit.name),
                          "RoomId": $util.toJson($exit.parentId),
                          "Ancestry": $util.toJson($exit.ancestry)
                      }#if($foreach.hasNext),#end
                  #end
              ]
  QueryGetRoomEntries:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Room
          FieldName: Entries
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "parentId = :RoomId",
                      "expressionValues": {
                          ":RoomId": $util.dynamodb.toDynamoDBJson($ctx.source.PermanentId)
                      }
                  },
                  "index": "parentIndex"
              }
          ResponseMappingTemplate: >
              [
                  #foreach($entry in $ctx.result.items)
                      {
                          "PermanentId": $util.toJson($entry.permanentId),
                          "Name": $util.toJson($entry.name),
                          "RoomId": $util.toJson($entry.fromRoomId),
                          "Ancestry": $util.toJson($entry.ancestry)
                      }#if($foreach.hasNext),#end
                  #end
              ]
  MutationPreQueryCharacterInPlay:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterInPlay
          Description: Checks before adding a character to see if a past record exists to reactivate
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if (!$ctx.prev.result.CharacterId)
                  $ctx.error("CharacterId required")
              #end
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.CharacterId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.result.PlayerName)
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "PlayerName": "$ctx.result.PlayerName",
                      "Name": "$ctx.result.Name",
                      "RoomId": "$ctx.result.RoomId",
                      "Reactivate": true
                  }
              #else
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "Reactivate": false
                  }
              #end
  MutationPreQueryCharacterIfNeeded:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterIfNeeded
          Description: Checks if needed before adding a character to find PlayerName and Name
          DataSourceName: !GetAtt CharacterDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if ($ctx.prev.result.Reactivate)
                  #return($ctx.prev.result)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toStringJson($ctx.prev.result.CharacterId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.error)
                  $util.error($ctx.error.message, $ctx.error.type)
              #end
              $util.toJson({
                  "CharacterId": "$ctx.prev.result.CharacterId",
                  "ConnectionId": "$ctx.prev.result.ConnectionId",
                  "PlayerName": "$ctx.result.PlayerName",
                  "Name": "$ctx.result.Name",
                  "RoomId": "VORTEX",
                  "Reactivate": false
              })
  MutationAddCharacterInPlayPutFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: AddCharacterInPlay
          Description: Adds or activates a CharacterInPlay record
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              {
                  #if ($ctx.prev.result.Reactivate)
                      "version": "2018-05-29",
                      "operation": "UpdateItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "update": {
                          "expression": "SET #connectionfield = :connectionId",
                          "expressionNames": {
                              "#connectionfield": "ConnectionId"
                          },
                          "expressionValues": {
                              ":connectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                          }
                      }
                  #else
                      "version" : "2017-02-28",
                      "operation": "PutItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "attributeValues": {
                          "PlayerName": $ddb.toDynamoDBJson($ctx.prev.result.PlayerName),
                          "Name": $ddb.toDynamoDBJson($ctx.prev.result.Name),
                          "RoomId": $ddb.toDynamoDBJson($ctx.prev.result.RoomId),
                          "ConnectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                      }
                  #end
              }
          ResponseMappingTemplate: "$util.toJson($ctx.prev.result)"
  MutationAddCharacterInPlay:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: addCharacterInPlay
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt MutationPreQueryCharacterInPlay.FunctionId
                  - !GetAtt MutationPreQueryCharacterIfNeeded.FunctionId
                  - !GetAtt MutationAddCharacterInPlayPutFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "CharacterId": $util.toJson($ctx.args.CharacterId),
                  "ConnectionId": $util.toJson($ctx.args.ConnectionId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterInPlayResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: deleteCharacterInPlay
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.error("CharacterId field required")
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2018-05-29",
                  "operation": "UpdateItem",
                  "key": {
                      "CharacterId": $ddb.toDynamoDBJson($ctx.args.CharacterId)
                  },
                  "update": {
                      "expression": "REMOVE #connectionfield",
                      "expressionNames": {
                          "#connectionfield": "ConnectionId"
                      }
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationMoveCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: moveCharacter
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.error("CharacterId field required")
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2018-05-29",
                  "operation": "UpdateItem",
                  "key": {
                      "CharacterId": $ddb.toDynamoDBJson($ctx.args.CharacterId)
                  },
                  "update": {
                      "expression": "SET #roomfield = :roomId",
                      "expressionNames": {
                          "#roomfield": "RoomId"
                      },
                      "expressionValues": {
                          ":roomId": $ddb.toDynamoDBJson($ctx.args.RoomId)
                      }
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationPreQueryPermanentParentFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryPermanentParent
          Description: Gets the parent node in order to construct ancestry
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if($ctx.prev.result.ParentId)
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "permanentId": $util.dynamodb.toStringJson($ctx.prev.result.ParentId)
                  }
              }
              #else
                  #return($ctx.prev.result)
              #end
          ResponseMappingTemplate: >
              #if ($ctx.error)
                  $util.error($ctx.error.message, $ctx.error.type)
              #end
              #set($prev = $ctx.prev.result)
              {
                  "Name": $util.toJson($prev.Name),
                  "PermanentId": $util.toJson($prev.PermanentId)
                  #if($prev.Description), "Description": $util.toJson($prev.Description)#end
                  #if($prev.ParentId), "ParentId": $util.toJson($prev.ParentId)#end
                  #if ($util.isMap($ctx.result))
                      #if ($ctx.result.ancestry)
                          , "ParentAncestry": $util.toJson($ctx.result.ancestry)
                      #end
                  #end
              }
  MutationPutNeighborhoodFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutNeighborhood
          Description: Puts a neighborhood into the Permanents table
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              #set( $args = $ctx.prev.result )
              #set( $PermanentId = $args.PermanentId )
              #if($util.isNullOrEmpty($PermanentId))
                  #set( $PermanentId = $util.autoId() )
              #end
              #if($args.ParentAncestry)
                  #set($ancestry = "${args.ParentAncestry}:${PermanentId}")
              #else
                  #set($ancestry = $PermanentId)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "permanentId": $ddb.toDynamoDBJson($PermanentId)
                  },
                  "attributeValues": {
                      "name": $ddb.toDynamoDBJson($args.Name),
                      "type": $ddb.toStringJson("NEIGHBORHOOD"),
                      "ancestry": $ddb.toStringJson($ancestry)
                      #if($args.Description), "description": $ddb.toStringJson($args.Description) #end
                      #if($args.ParentId), "parentId": $ddb.toStringJson($args.ParentId) #end
                  }
              }
          ResponseMappingTemplate: >
              {
                  "PermanentId": $util.toJson($ctx.result.permanentId),
                  "ParentId": $util.toJson($ctx.result.parentId),
                  "Type": "NEIGHBORHOOD",
                  "Ancestry": $util.toJson($ctx.result.ancestry),
                  "Name": $util.toJson($ctx.result.name),
                  "Description": $util.toJson($ctx.result.description)
              }
  MutationPutNeighborhood:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putNeighborhood
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt MutationPreQueryPermanentParentFunction.FunctionId
                  - !GetAtt MutationPutNeighborhoodFunction.FunctionId
          RequestMappingTemplate: "$util.toJson($ctx.args)"
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  UUIDLambdaLayer:
      Type: AWS::Serverless::LayerVersion
      Properties:
          LayerName: uuid-layer
          Description: Lambda layer to import the uuid library
          ContentUri: lambda/uuidLayer/
          CompatibleRuntimes:
              - nodejs12.x
  PutRoomPathsFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/putRoomPaths/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  PutRoomPermission:
      Type: AWS::Lambda::Permission
      DependsOn:
          - PutRoomPathsFunction
      Properties:
          Action: lambda:InvokeFunction
          FunctionName: !Ref PutRoomPathsFunction
          Principal: appsync.amazonaws.com
  MutationPutRoomBaseFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomBase
          Description: Puts a room record into the Permanents table
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              #set( $args = $ctx.prev.result )
              #set( $PermanentId = $args.PermanentId )
              #if($util.isNullOrEmpty($PermanentId))
                  #set( $PermanentId = $util.autoId() )
              #end
              #if($args.ParentAncestry)
                  #set($ancestry = "${args.ParentAncestry}:${PermanentId}")
              #else
                  #set($ancestry = $PermanentId)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "PutItem",
                  "key": {
                      "permanentId": $ddb.toDynamoDBJson($PermanentId)
                  },
                  "attributeValues": {
                      "name": $ddb.toDynamoDBJson($args.Name),
                      "type": $ddb.toStringJson("ROOM"),
                      "ancestry": $ddb.toStringJson($ancestry)
                      #if($args.Description), "description": $ddb.toStringJson($args.Description) #end
                      #if($args.ParentId), "parentId": $ddb.toStringJson($args.ParentId) #end
                  }
              }
          ResponseMappingTemplate: >
              #set($output = {
                  "PermanentId": $ctx.result.permanentId,
                  "Type": "ROOM",
                  "Ancestry": $ctx.result.ancestry,
                  "Name": $ctx.result.name,
                  "Exits": $ctx.prev.result.Exits,
                  "Entries": $ctx.prev.result.Entries
              })
              #if($ctx.prev.result.ParentId)$util.qr($output.put("ParentId", $ctx.prev.result.ParentId))#end
              #if($ctx.prev.result.Description)$util.qr($output.put("Description", $ctx.prev.result.Description))#end
              $util.toJson($output)
  PutRoomPathsDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomPath
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutRoomPathsFunction.Arn
  MutationPutRoomPathsFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoomPaths
          Description: Puts the needed entry records into the Permanents table
          DataSourceName: !GetAtt PutRoomPathsDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "source": {
                          "PermanentId": $util.toJson($ctx.prev.result.PermanentId),
                          "Ancestry": $util.toJson($ctx.prev.result.Ancestry)
                      },
                      "Exits": $util.toJson($ctx.prev.result.Exits),
                      "Entries": $util.toJson($ctx.prev.result.Entries)
                  }
              }
          ResponseMappingTemplate: >
              #set($output = {
                  "PermanentId": $ctx.prev.result.PermanentId,
                  "Type": "ROOM",
                  "Ancestry": $ctx.prev.result.Ancestry,
                  "Name": $ctx.prev.result.Name,
                  "Exits": $ctx.prev.result.Exits,
                  "Entries": $ctx.prev.result.Entries
              })
              #if($ctx.prev.result.ParentId)$util.qr($output.put("ParentId", $ctx.prev.result.ParentId))#end
              #if($ctx.prev.result.Description)$util.qr($output.put("Description", $ctx.prev.result.Description))#end
              $util.toJson($output)
  MutationPutRoom:
      Type: AWS::AppSync::Resolver
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putRoom
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                - !GetAtt MutationPutRoomBaseFunction.FunctionId
                - !GetAtt MutationPutRoomPathsFunction.FunctionId
          RequestMappingTemplate: "$util.toJson($ctx.args)"
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  Schema:
      Type: AWS::AppSync::GraphQLSchema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Definition: >
              type Character @aws_iam @aws_cognito_user_pools {
                  PlayerName: String!
                  Name: String!
                  CharacterId: ID!
                  Pronouns: String
                  FirstImpression: String
                  Outfit: String
                  OneCoolThing: String
              }
              type CharacterInPlay @aws_iam @aws_cognito_user_pools {
                  CharacterId: ID!
                  Character: Character!
                  RoomId: String!
                  ConnectionId: String!
              }
              interface PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
              }
              type Neighborhood implements PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
              }
              interface RoomPath {
                  PermanentId: String
                  Name: String!
                  RoomId: String
                  Ancestry: String
              }
              type Exit implements RoomPath {
                  PermanentId: String!
                  Name: String!
                  RoomId: String!
                  Ancestry: String!
              }
              type Entry implements RoomPath {
                  PermanentId: String!
                  Name: String!
                  RoomId: String!
                  Ancestry: String!
              }
              input PathInput {
                  PermanentId: String
                  Name: String!
                  RoomId: String
              }
              type Room implements PermanentTreeNode {
                  PermanentId: String!
                  Type: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
                  Exits: [Exit]
                  Entries: [Entry]
              }
              type Mutation {
                  putCharacter(
                      Name: String!,
                      CharacterId: String,
                      Pronouns: String,
                      FirstImpression: String,
                      Outfit: String,
                      OneCoolThing: String
                  ): Character
                  addCharacterInPlay(
                      CharacterId: String!
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  deleteCharacterInPlay(
                      CharacterId: String!
                  ): CharacterInPlay
                  moveCharacter(
                      CharacterId: String!
                      RoomId: String!
                  ): CharacterInPlay
                  putNeighborhood(
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                  ): Neighborhood
                  putRoom(
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                      Exits: [PathInput]
                      Entries: [PathInput]
                  ): Room
              }
              type Query {
                  getCharacter(playerName: String!, name: String!): Character
                  getPlayerCharacters: [Character]
                  getCharactersInPlay: [CharacterInPlay]
                  getNeighborhoodTree: [PermanentTreeNode]
                  getNeighborhood(PermanentId: String!): Neighborhood
                  getRoom(PermanentId: String!): Room
                  getRoomByCharacter(CharacterId: String!): Room
              }
              type Subscription {
                  changedCharacter: Character
                  @aws_subscribe(mutations: ["putCharacter"])
                  changedCharactersInPlay: CharacterInPlay
                  @aws_subscribe(mutations: ["addCharacterInPlay"])
                  changedNeighborhood: Neighborhood
                  @aws_subscribe(mutations: ["putNeighborhood"])
                  changedRoom: Room
                  @aws_subscribe(mutations: ["putRoom"])
              }
              schema {
                  mutation: Mutation
                  query: Query
                  subscription: Subscription
              }

Outputs:
  WebSocketURI:
    Description: "The WSS Protocol URI to connect to for realtime messages"
    Value: !Join [ '', [ 'wss://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/',!Ref 'RealTimeStage'] ]

  UserPoolArn:
    Description: The ARN for the player user pool"
    Value: !GetAtt 'UserPool.Arn'

  UserPoolClient:
    Description: The client ID for the player user pool
    Value: !Ref UserPoolClient

  AppSyncAPI:
    Description: The ID of the AppSync Api
    Value: !Ref AppSyncAPI