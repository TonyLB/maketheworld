AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  burnedover-mush-app

  SAM Template for burnedover-mush, a serverless multiplayer text roleplaying system,
  with DynamoDB storage, React front-end and administrative tools.

Parameters:
  TablePrefix:
    Type: String
    Default: 'burnedover'
    Description: (Required) The name of the new DynamoDB to store connection identifiers for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'
  PermanentsStack:
    Type: String
    Default: 'BurnedOverPermanentsStack'
    Description: (Required) The name of the stack containing the permanents DynamoDB table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'

Resources:
  RealTimeWebSocket:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: BurnedOverRealTimeSocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.message"
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref ConnectInteg
  ConnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Connect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnConnectFunction.Arn}/invocations
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DisconnectInteg
  DisconnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri: 
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${OnDisconnectFunction.Arn}/invocations
  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: ping
      AuthorizationType: NONE
      OperationName: PingRoute
      RouteResponseSelectionExpression: "$default"
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref PingInteg
  PingInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Ping Integration
      IntegrationType: MOCK
      PassthroughBehavior: WHEN_NO_MATCH
      TemplateSelectionExpression: "application/json"
      RequestTemplates:
        application/json: "{\"statusCode\": 200 }"
  PingIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref PingInteg
      TemplateSelectionExpression: "$integration.response.statuscode"
      IntegrationResponseKey: "/200/"
      ResponseTemplates:
        "200": "{\"statusCode\": 200, \"type\": \"pong\" }"
  PingResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref PingRoute
      RouteResponseKey: "$default"
  RegisterCharacterRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: registercharacter
      AuthorizationType: NONE
      OperationName: RegisterCharacterRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref RegisterCharacterInteg
  RegisterCharacterInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Register Name Integtration
      IntegrationType: AWS_PROXY
      IntegrationUri:
        Fn::Sub:
            arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RegisterCharacterFunction.Arn}/invocations
  RealTimeDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
    - ConnectRoute
    - PingRoute
    - RegisterCharacterRoute
    - DisconnectRoute
    Properties:
      ApiId: !Ref RealTimeWebSocket
  RealTimeStage:
    Type: AWS::ApiGatewayV2::Stage
    DependsOn:
      - RealTimeDeployment
    Properties:
      StageName: Prod
      Description: Prod Stage
      DeploymentId: !Ref RealTimeDeployment
      ApiId: !Ref RealTimeWebSocket
  CharactersInPlayTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "CharacterId"
        AttributeType: "S"
      - AttributeName: "RoomId"
        AttributeType: "S"
      - AttributeName: "ConnectionId"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "CharacterId"
        KeyType: "HASH"
      GlobalSecondaryIndexes:
        - IndexName: RoomIndex
          KeySchema:
            - AttributeName: RoomId
              KeyType: HASH
            - AttributeName: CharacterId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: ConnectionIndex
          KeySchema:
            - AttributeName: ConnectionId
              KeyType: HASH
            - AttributeName: CharacterId
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      SSESpecification:
        SSEEnabled: False
      TimeToLiveSpecification:
        AttributeName: "ExpirationTime"
        Enabled: True
      TableName: !Sub '${TablePrefix}_characters_in_play'
  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "Target"
        AttributeType: "S"
      - AttributeName: "DataCategory"
        AttributeType: "S"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "Target"
        KeyType: "HASH"
      - AttributeName: "DataCategory"
        KeyType: "RANGE"
      SSESpecification:
        SSEEnabled: False
      TableName: !Sub '${TablePrefix}_messages'
      TimeToLiveSpecification:
        AttributeName: ExpirationTime
        Enabled: True
  SharedLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: shared-layer
        Description: Lambda layer with shared code for functions
        ContentUri: lambda/shared/
        CompatibleRuntimes:
          - nodejs12.x
  AppSyncLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: appsync-layer
        Description: Lambda layer to import the appsync libraries
        ContentUri: lambda/appSyncLayer/
        CompatibleRuntimes:
          - nodejs12.x
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: uuid-layer
        Description: Lambda layer to import the uuid library
        ContentUri: lambda/uuidLayer/
        CompatibleRuntimes:
          - nodejs12.x
  OnConnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/onconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
  OnConnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnConnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnConnectFunction
      Principal: apigateway.amazonaws.com
  OnDisconnectFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/ondisconnect/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
      - Statement:
        - Effect: Allow
          Action: appsync:GraphQL
          Resource: !Sub '${AppSyncAPI}/*'
  OnDisconnectPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - OnDisconnectFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref OnDisconnectFunction
      Principal: apigateway.amazonaws.com
  RegisterCharacterFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/registercharacter/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Layers:
        - !Ref SharedLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
      - Statement:
        - Effect: Allow
          Action:
          - 'execute-api:ManageConnections'
          Resource:
          - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
      - Statement:
        - Effect: Allow
          Action: appsync:GraphQL
          Resource: !Sub '${AppSyncAPI}/*'
  RegisterCharacterPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - RegisterCharacterFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref RegisterCharacterFunction
      Principal: apigateway.amazonaws.com
  CreateBackupFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/createBackup/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          S3_BUCKET: burnedover-admin
      Policies:
        - Statement:
          - Effect: Allow
            Action: appsync:GraphQL
            Resource: !Sub '${AppSyncAPI}/*'
        - Statement:
          - Effect: Allow
            Action: s3:PutObject
            Resource:
              - arn:aws:s3:::burnedover-admin/*
          - Effect: "Allow"
            Action:
              - "dynamodb:Scan"
            Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
          - Effect: "Allow"
            Action:
              - "dynamodb:Scan"
            Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_players"
  RestoreBackupFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/restoreBackup/
      Handler: app.handler
      MemorySize: 256
      Runtime: nodejs12.x
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          S3_BUCKET: burnedover-admin
      Policies:
        - Statement:
          - Effect: Allow
            Action: appsync:GraphQL
            Resource: !Sub '${AppSyncAPI}/*'
        - Statement:
          - Effect: Allow
            Action: s3:GetObject
            Resource:
              - arn:aws:s3:::burnedover-admin/*
          - Effect: "Allow"
            Action:
              - "dynamodb:BatchWriteItem"
            Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
  AppSyncAPI:
      Type: AWS::AppSync::GraphQLApi
      Properties:
          Name: !Sub ${TablePrefix}AppSyncAPI
          AuthenticationType: AMAZON_COGNITO_USER_POOLS
          UserPoolConfig:
              AwsRegion: us-east-1
              UserPoolId:
                Fn::ImportValue:
                  !Sub "${PermanentsStack}-UserPoolId"
              DefaultAction: ALLOW
          AdditionalAuthenticationProviders:
              - AuthenticationType: AWS_IAM
  AppSyncAPIExecutionRole:
      Type: AWS::IAM::Role
      Properties:
          AssumeRolePolicyDocument:
              Statement:
                - Effect: Allow
                  Principal:
                      Service: appsync.amazonaws.com
                  Action:
                      - sts:AssumeRole
          Policies:
            - PolicyName: CharactersPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters"
            - PolicyName: CharacterIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters/*"
            - PolicyName: PlayersPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_players"
            - PolicyName: PlayerIndexPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource: !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_players/*"
            - PolicyName: TablesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages"
            - PolicyName: IndexesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_characters_in_play/*"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages/*"
            - PolicyName: AppSyncLambdasPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "lambda:InvokeFunction"
                      Resource:
                        - !GetAtt PutCharacterFunction.Arn
                        - !GetAtt GetNodeTreeFunction.Arn
                        - !GetAtt GetPlayerCharactersFunction.Arn
                        - !GetAtt GetCharacterFunction.Arn
                        - !GetAtt GetNeighborhoodFunction.Arn
                        - !GetAtt PutNeighborhoodFunction.Arn
                        - !GetAtt PutRoomFunction.Arn
                        - !GetAtt GetMapsFunction.Arn
                        - !GetAtt PutMapFunction.Arn
  CharactersInPlayDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: CharactersInPlay
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_characters_in_play
  PermanentsDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: Permanents
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: us-east-1
              TableName: !Sub ${TablePrefix}_permanents
  MessagesDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: Messages
        Type: AMAZON_DYNAMODB
        ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
        DynamoDBConfig:
            AwsRegion: us-east-1
            TableName: !Sub ${TablePrefix}_messages
  QueryGetPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getPlayer
        DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "GetItem",
                "key": {
                    "PermanentId": $util.dynamodb.toStringJson("PLAYER#${ctx.args.PlayerName}"),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                }
            }
        ResponseMappingTemplate: >
            #set($Consent = false)
            #if ($ctx.result && $util.isBoolean($ctx.result.CodeOfConductConsent))
                #set($Consent = $ctx.result.CodeOfConductConsent)
            #end
            $util.toJson({
                "PlayerName": $ctx.args.PlayerName,
                "CodeOfConductConsent": $Consent
            })
  MutationPutPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putPlayer
        DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            $util.qr($ctx.stash.put("PlayerName", $ctx.args.PlayerName))
            #if ($util.isNullOrEmpty($PlayerName))
              $util.qr($ctx.stash.put("PlayerName", $context.identity.username))
            #end
            {
                "version": "2017-02-28",
                "operation": "PutItem",
                "key": {
                    "PermanentId": $util.dynamodb.toStringJson("PLAYER#${ctx.stash.PlayerName}"),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                },
                "attributeValues": {
                    "CodeOfConductConsent":
                      #if($ctx.args.CodeOfConductConsent)
                        $util.dynamodb.toBooleanJson($ctx.args.CodeOfConductConsent)
                      #else
                        $util.dynamodb.toBooleanJson(false)
                      #end
                }
            }
        ResponseMappingTemplate: >
          $util.toJson({
            "Type": "PLAYER",
            "PlayerName": $ctx.stash.PlayerName,
            "PlayerInfo": {
              "PlayerName": $ctx.stash.PlayerName,
              "CodeOfConductConsent": $util.defaultIfNull($ctx.result.CodeOfConductConsent, false)
            }
          })
  GetCharacterFunction:
    Type: AWS::Serverless::Function
    Properties:
        CodeUri: lambda/permanents/characters/
        Handler: app.getCharacter
        MemorySize: 256
        Runtime: nodejs12.x
        Layers:
            - !Ref UUIDLambdaLayer
        Environment:
            Variables:
                TABLE_PREFIX: !Ref TablePrefix
        Policies:
          - DynamoDBReadPolicy:
                TableName: !Sub '${TablePrefix}_permanents'
  GetCharacterDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetCharacter
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt GetCharacterFunction.Arn
  QueryGetCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharacter
          DataSourceName: !GetAtt GetCharacterDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "CharacterId": $utils.toJson($ctx.args.CharacterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  GetPlayerCharactersFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/characters/
          Handler: app.getPlayerCharacters
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBReadPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  GetPlayerCharactersDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetPlayerCharacters
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt GetPlayerCharactersFunction.Arn
  QueryPlayerCharactersResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getPlayerCharacters
          DataSourceName: !GetAtt GetPlayerCharactersDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "PlayerName": $util.toJson($context.identity.username)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  PutCharacterFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/characters/
          Handler: app.putCharacter
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  PutCharacterDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutCharacter
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutCharacterFunction.Arn
  PutCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putCharacter
          DataSourceName: !GetAtt PutCharacterDataSource.Name
          RequestMappingTemplate: >
              #set($arguments = $ctx.args)
              $util.qr($arguments.put("PlayerName", $context.identity.username))
              $util.toJson({
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": $arguments
              })
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  CharacterInPlayGetCharacter:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: CharacterInPlay
          FieldName: Character
          DataSourceName: !GetAtt GetCharacterDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "CharacterId": $utils.toJson($context.source.CharacterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetCharactersInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharactersInPlay
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Scan"
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result.items)"
  GetNodeTreeFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/nodeTree/
          Handler: app.getNodeTree
          MemorySize: 256
          Runtime: nodejs12.x
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBReadPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  GetNodeTreeDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetNodeTree
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt GetNodeTreeFunction.Arn
  QueryGetNeighborhoodTree:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getNeighborhoodTree
          DataSourceName: !GetAtt GetNodeTreeDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {}
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  GetNeighborhoodFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/neighborhoods/
          Handler: app.getNeighborhood
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - DynamoDBReadPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  GetNeighborhoodDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetNeighborhood
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt GetNeighborhoodFunction.Arn
  QueryGetNeighborhood:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
      - GetNeighborhoodFunction
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getNeighborhood
        DataSourceName: !GetAtt GetNeighborhoodDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Invoke",
                "payload": {
                    "PermanentId": $utils.toJson($ctx.args.PermanentId)
                }
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGetRoom:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getRoom
          DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set($PermanentId = "ROOM#${ctx.args.PermanentId}")
              {
                  "version": "2017-02-28",
                  "operation": "Query",
                  "query": {
                      "expression": "PermanentId = :PermanentId",
                      "expressionValues": {
                          ":PermanentId": $util.dynamodb.toDynamoDBJson($PermanentId)
                      }
                  }
              }
          ResponseMappingTemplate: >
              #set($output = { "Type": "ROOM" })
              #set($entries = [])
              #set($exits = [])
              #foreach($row in $ctx.result.items)
                  #if ($row.DataCategory == 'Details')
                      $util.qr($output.put("PermanentId", $row.PermanentId.substring(5)))
                      $util.qr($output.put("ParentId", $row.ParentId))
                      $util.qr($output.put("Ancestry", $row.Ancestry))
                      $util.qr($output.put("Name", $row.Name))
                      $util.qr($output.put("Description", $row.Description))
                      $util.qr($output.put("Visibility", "Public"))
                  #end
                  #if ($row.DataCategory.startsWith('EXIT#'))
                      #set($roomId = $row.DataCategory.substring(5))
                      $util.qr($exits.add({
                          "Name": $row.Name,
                          "RoomId": $roomId,
                          "Ancestry": $row.Ancestry
                      }))
                  #end
                  #if ($row.DataCategory.startsWith('ENTRY#'))
                      #set($roomId = $row.DataCategory.substring(6))
                      $util.qr($entries.add({
                          "Name": $row.Name,
                          "RoomId": $roomId
                      }))
                  #end
              #end
              $util.qr($output.put("Exits", $exits))
              $util.qr($output.put("Entries", $entries))
              $util.qr($output.put("Grants", []))
              $util.toJson($output)
  QueryGetRoomRecap:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getRoomRecap
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Query",
                "query": {
                  "expression": "Target = :RoomId",
                  "expressionValues": {
                      ":RoomId": $util.dynamodb.toDynamoDBJson("ROOM#$ctx.args.PermanentId")
                  }
                },
                "scanIndexForward": false,
                "limit": 10
            }
        ResponseMappingTemplate: >
            #set($output = [])
            #foreach($message in $ctx.result.items)
                #set($split = $message.DataCategory.split("#"))
                $util.qr($output.add({
                    "Target": "$ctx.result.Target",
                    "RoomId": "$ctx.args.PermanentId",
                    "Type": "$util.defaultIfNull($message.Type, 'ROOM')",
                    "CreatedTime": $split[0],
                    "MessageId": "$split[1]",
                    "Recap": true,
                    "Message": "$message.Message",
                    "FromCharacterId": "$util.defaultIfNull($message.FromCharacterId, '')",
                    "Title": "$util.defaultIfNull($message.Title, '')"
                }))
            #end
            $util.toJson($output)
  QueryGetRoles:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getRoles
        DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Query",
                "query": {
                  "expression": "PermanentId = :Admin and begins_with(DataCategory, :Role)",
                  "expressionValues": {
                      ":Admin": $util.dynamodb.toStringJson("ADMIN"),
                      ":Role": $util.dynamodb.toStringJson("ROLE#")
                  }
                }
            }
        ResponseMappingTemplate: >
            #set($output = [])
            #foreach($role in $ctx.result.items)
                #set($roleId = $role.DataCategory.split("#")[1])
                $util.qr($output.add({
                    "RoleId": $roleId,
                    "Name": $role.Name,
                    "Actions": $role.Actions
                }))
            #end
            $util.toJson($output)
  GetMapsFunction:
    Type: AWS::Serverless::Function
    Properties:
        CodeUri: lambda/permanents/maps/
        Handler: app.getMaps
        MemorySize: 256
        Runtime: nodejs12.x
        Environment:
            Variables:
                TABLE_PREFIX: !Ref TablePrefix
        Policies:
          - DynamoDBReadPolicy:
                TableName: !Sub '${TablePrefix}_permanents'
  GetMapsDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: GetMaps
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt GetMapsFunction.Arn
  QueryGetMapsResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getMaps
          DataSourceName: !GetAtt GetMapsDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {}
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  PutMapFunction:
    Type: AWS::Serverless::Function
    Properties:
        CodeUri: lambda/permanents/maps/
        Handler: app.putMap
        MemorySize: 256
        Runtime: nodejs12.x
        Environment:
            Variables:
                TABLE_PREFIX: !Ref TablePrefix
        Policies:
          - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_permanents'
  PutMapDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutMap
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutMapFunction.Arn
  MutationPutMapResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putMap
          DataSourceName: !GetAtt PutMapDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "arguments": $utils.toJson($ctx.args)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationPreQueryCharacterInPlay:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterInPlay
          Description: Checks before adding a character to see if a past record exists to reactivate
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if (!$ctx.prev.result.CharacterId)
                  $ctx.error("CharacterId required")
              #end
              {
                  "version": "2017-02-28",
                  "operation": "GetItem",
                  "key": {
                      "CharacterId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.CharacterId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.result.PlayerName)
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "PlayerName": "$ctx.result.PlayerName",
                      "Name": "$ctx.result.Name",
                      "RoomId": "$ctx.result.RoomId",
                      "Reactivate": true
                  }
              #else
                  {
                      "CharacterId": "$ctx.prev.result.CharacterId",
                      "ConnectionId": "$ctx.prev.result.ConnectionId",
                      "Reactivate": false
                  }
              #end
  MutationPreQueryCharacterIfNeeded:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PreQueryCharacterIfNeeded
          Description: Checks if needed before adding a character to find PlayerName and Name
          DataSourceName: !GetAtt GetCharacterDataSource.Name
          RequestMappingTemplate: >
              #if ($ctx.prev.result.Reactivate)
                  #return($ctx.prev.result)
              #end
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "CharacterId": $utils.toJson($ctx.prev.result.CharacterId)
                  }
              }
          ResponseMappingTemplate: >
              #if ($ctx.error)
                  $util.error($ctx.error.message, $ctx.error.type)
              #end
              #if($ctx.result)
                #set($result = $ctx.result)
                $util.toJson({
                  "CharacterId": "$ctx.prev.result.CharacterId",
                  "ConnectionId": "$ctx.prev.result.ConnectionId",
                  "PlayerName": "$result.PlayerName",
                  "Name": "$result.Name",
                  "RoomId": "$util.defaultIfNullOrBlank($result.HomeId, 'VORTEX')",
                  "Grants": $util.defaultIfNull($result.Grants, []),
                  "Reactivate": false
                })
              #else
                $util.error("No character found")
              #end
  MutationAddCharacterInPlayPutFunction:
      Type: AWS::AppSync::FunctionConfiguration
      Properties:
          FunctionVersion: "2018-05-29"
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: AddCharacterInPlay
          Description: Adds or activates a CharacterInPlay record
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #set( $ddb = $util.dynamodb )
              {
                  #if ($ctx.prev.result.Reactivate)
                      "version": "2018-05-29",
                      "operation": "UpdateItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "update": {
                          "expression": "SET #connectionfield = :connectionId",
                          "expressionNames": {
                              "#connectionfield": "ConnectionId"
                          },
                          "expressionValues": {
                              ":connectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                          }
                      }
                  #else
                      "version" : "2017-02-28",
                      "operation": "PutItem",
                      "key": {
                          "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                      },
                      "attributeValues": {
                          "PlayerName": $ddb.toDynamoDBJson($ctx.prev.result.PlayerName),
                          "Name": $ddb.toDynamoDBJson($ctx.prev.result.Name),
                          "RoomId": $ddb.toDynamoDBJson($ctx.prev.result.RoomId),
                          "ConnectionId": $ddb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                      }
                  #end
              }
          ResponseMappingTemplate: "$util.toJson($ctx.prev.result)"
  MutationAddCharacterInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: addCharacterInPlay
          Kind: PIPELINE
          PipelineConfig:
              Functions:
                  - !GetAtt MutationPreQueryCharacterInPlay.FunctionId
                  - !GetAtt MutationPreQueryCharacterIfNeeded.FunctionId
                  - !GetAtt MutationAddCharacterInPlayPutFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "CharacterId": $util.toJson($ctx.args.CharacterId),
                  "ConnectionId": $util.toJson($ctx.args.ConnectionId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterPreFetchFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
        FunctionVersion: "2018-05-29"
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: DeleteCharacterPreFetch
        Description: Finds the CharactedId for the first CharacterInPlay record of a given ConnectionId
        DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
              "version": "2017-02-28",
              "operation": "Query",
              "query": {
                  "expression": "ConnectionId = :ConnectionId",
                  "expressionValues": {
                      ":ConnectionId": $util.dynamodb.toDynamoDBJson($ctx.prev.result.ConnectionId)
                  }
              },
              "index": "ConnectionIndex"
            }
        ResponseMappingTemplate: >
            #if ($ctx.result.items)
              $util.toJson({
                "CharacterId": "$ctx.result.items[0].CharacterId"
              })
            #else
              {}
            #end
  MutationDeleteCharacterFunction:
    Type: AWS::AppSync::FunctionConfiguration
    Properties:
        FunctionVersion: "2018-05-29"
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: DeleteCharacterPreFetch
        Description: Finds the CharactedId for the first CharacterInPlay record of a given ConnectionId
        DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #if(!($ctx.prev.result.CharacterId))
                $util.error("CharacterId field required")
            #end
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "UpdateItem",
                "key": {
                    "CharacterId": $ddb.toDynamoDBJson($ctx.prev.result.CharacterId)
                },
                "update": {
                    "expression": "REMOVE #connectionfield",
                    "expressionNames": {
                        "#connectionfield": "ConnectionId"
                    }
                }
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterInPlayResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: deleteCharacterInPlay
          Kind: PIPELINE
          PipelineConfig:
            Functions:
                - !GetAtt MutationDeleteCharacterPreFetchFunction.FunctionId
                - !GetAtt MutationDeleteCharacterFunction.FunctionId
          RequestMappingTemplate: >
              {
                  "ConnectionId": $util.toJson($ctx.args.ConnectionId)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationMoveCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: moveCharacter
          DataSourceName: !GetAtt CharactersInPlayDynamoDBTableDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.error("CharacterId field required")
              #end
              #if(!($ctx.args.RoomId))
                  $util.error("RoomId field required")
              #end
              #set( $ddb = $util.dynamodb )
              {
                  "version": "2018-05-29",
                  "operation": "UpdateItem",
                  "key": {
                      "CharacterId": $ddb.toDynamoDBJson($ctx.args.CharacterId)
                  },
                  "update": {
                      "expression": "SET #roomfield = :roomId",
                      "expressionNames": {
                          "#roomfield": "RoomId"
                      },
                      "expressionValues": {
                          ":roomId": $ddb.toDynamoDBJson($ctx.args.RoomId)
                      }
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  PutNeighborhoodFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/neighborhoods/
          Handler: app.putNeighborhood
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
            - Statement:
              - Effect: Allow
                Action: appsync:GraphQL
                Resource: !Sub '${AppSyncAPI}/*'
  PutNeighborhoodDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutNeighborhood
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutNeighborhoodFunction.Arn
  MutationPutNeighborhood:
      Type: AWS::AppSync::Resolver
      DependsOn:
        - Schema
        - PutNeighborhoodFunction
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: putNeighborhood
          DataSourceName: !GetAtt PutNeighborhoodDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "arguments": $utils.toJson($ctx.args)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  NoneDataSource:
    Type: AWS::AppSync::DataSource
    DependsOn:
      - Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: NoneSource
        Type: NONE
  MutationExternalPutNeighborhood:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: externalPutNeighborhood
        DataSourceName: !GetAtt NoneDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "payload": $util.toJson($ctx.args)
            }
        ResponseMappingTemplate: >
            #set($result = $ctx.result)
            $util.toJson([{ Neighborhood: $result }])
  MutationExternalUpdateGrant:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: externalUpdateGrant
        DataSourceName: !GetAtt NoneDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "payload": $util.toJson($ctx.args)
            }
        ResponseMappingTemplate: >
            #set($result = $ctx.result)
            #set($grant = $result.Grant)
            $util.toJson({
                  "Type": "$result.Type",
                  "PlayerName": "$result.PlayerName",
                  "CharacterId": "$result.CharacterId",
                  "GrantInfo": $grant
            })
  UUIDLambdaLayer:
      Type: AWS::Serverless::LayerVersion
      Properties:
          LayerName: uuid-layer
          Description: Lambda layer to import the uuid library
          ContentUri: lambda/uuidLayer/
          CompatibleRuntimes:
              - nodejs12.x
  PutRoomFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/permanents/putRoom/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  PutRoomDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PutRoom
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PutRoomFunction.Arn
  MutationPutRoom:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
      - PutRoomFunction
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putRoom
        DataSourceName: !GetAtt PutRoomDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Invoke",
                "payload": {
                    "arguments": $utils.toJson($ctx.args)
                }
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationExternalPutRoom:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
    Properties:
      ApiId: !GetAtt AppSyncAPI.ApiId
      TypeName: Mutation
      FieldName: externalPutRoom
      DataSourceName: !GetAtt NoneDataSource.Name
      RequestMappingTemplate: >
          {
              "version": "2017-02-28",
              "payload": $util.toJson($ctx.args)
          }
      ResponseMappingTemplate: >
          #set($result = $ctx.result)
          $util.toJson([{ Room: $result }])
  MutationPutRoomMessage:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putRoomMessage
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #set($args = $ctx.args)
            #if($util.isNullOrEmpty($args.RoomId))
                $util.error("RoomId field required")
            #end
            #set ($MessageId = $util.defaultIfNullOrBlank($args.MessageId, $util.autoId()))
            #set ($CreatedTime = $util.defaultIfNull($args.CreatedTime, $util.time.nowEpochMilliSeconds()))
            #set ($MessageType = $util.defaultIfNullOrBlank($args.MessageType, "ROOM"))
            #set ($ExpirationTime = $util.time.nowEpochSeconds() + 600)
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "PutItem",
                "key": {
                    "Target": $ddb.toDynamoDBJson("ROOM#${args.RoomId}"),
                    "DataCategory": $ddb.toDynamoDBJson("${CreatedTime}#${MessageId}")
                },
                "attributeValues": {
                    "ExpirationTime": $ddb.toNumberJson($ExpirationTime),
                    "Recap": $ddb.toBooleanJson(false),
                    "Type": $ddb.toStringJson($MessageType)
                    #if(!$util.isNullOrEmpty($args.Message)), "Message": $ddb.toStringJson($args.Message) #end
                    #if(!$util.isNullOrEmpty($args.FromCharacterId)), "FromCharacterId": $ddb.toStringJson($args.FromCharacterId) #end
                    #if(!$util.isNullOrEmpty($args.Title)), "Title": $ddb.toStringJson($args.Title) #end
                }
            }
        ResponseMappingTemplate: >
            #set($split = $ctx.result.DataCategory.split("#"))
            {
                "Target": $util.toJson(${ctx.result.Target}),
                "RoomId": $util.toJson(${ctx.args.RoomId}),
                "Type": $util.toJson($util.defaultIfNull($ctx.result.Type, 'ROOM')),
                "CreatedTime": $util.toJson($split[0]),
                "MessageId": $util.toJson($split[1]),
                "Recap": $util.toJson(false),
                "Message": $util.toJson($ctx.result.Message),
                "FromCharacterId": $util.toJson($util.defaultIfNull($ctx.result.FromCharacterId, '')),
                "ToCharacterId": $util.toJson($util.defaultIfNull($ctx.result.FromCharacterId, '')),
                "Title": $util.toJson($util.defaultIfNull($ctx.result.Title, '')),
                "CharacterId": $util.toJson($util.defaultIfNull($ctx.result.CharacterId, '')),
                "ExpirationTime": $util.toJson($util.defaultIfNull($ctx.result.ExpirationTime, 0))
            }
  MutationPutDirectMessage:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putDirectMessage
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #set($args = $ctx.args)
            #if($util.isNullOrEmpty($args.CharacterId))
                $util.error("CharacterId field required")
            #end
            #set ($MessageId = $util.defaultIfNullOrBlank($args.MessageId, $util.autoId()))
            #set ($CreatedTime = $util.defaultIfNull($args.CreatedTime, $util.time.nowEpochMilliSeconds()))
            #set ($ExpirationTime = $util.time.nowEpochSeconds() + 600)
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "PutItem",
                "key": {
                    "Target": $ddb.toDynamoDBJson("CHARACTER#${args.CharacterId}"),
                    "DataCategory": $ddb.toDynamoDBJson("${CreatedTime}#${MessageId}")
                },
                "attributeValues": {
                    "ExpirationTime": $ddb.toNumberJson($ExpirationTime),
                    "Recap": $ddb.toBooleanJson(false),
                    "Type": $ddb.toStringJson("DIRECT")
                    #if(!$util.isNullOrEmpty($args.Message)), "Message": $ddb.toStringJson($args.Message) #end
                    #if(!$util.isNullOrEmpty($args.FromCharacterId)), "FromCharacterId": $ddb.toStringJson($args.FromCharacterId) #end
                    #if(!$util.isNullOrEmpty($args.ToCharacterId)), "ToCharacterId": $ddb.toStringJson($args.ToCharacterId) #end
                }
            }
        ResponseMappingTemplate: >
            #set($split = $ctx.result.DataCategory.split("#"))
            {
                "Target": $util.toJson(${ctx.result.Target}),
                "CharacterId": $util.toJson(${ctx.args.CharacterId}),
                "Type": "DIRECT",
                "CreatedTime": $util.toJson($split[0]),
                "MessageId": $util.toJson($split[1]),
                "Recap": $util.toJson(false),
                "Message": $util.toJson($ctx.result.Message),
                "FromCharacterId": $util.toJson($util.defaultIfNull($ctx.result.FromCharacterId, '')),
                "ToCharacterId": $util.toJson($util.defaultIfNull($ctx.result.ToCharacterId, '')),
                "Title": $util.toJson($util.defaultIfNull($ctx.result.Title, '')),
                "RoomId": $util.toJson($util.defaultIfNull($ctx.result.RoomId, '')),
                "ExpirationTime": $util.toJson($util.defaultIfNull($ctx.result.ExpirationTime, 0))
            }
  Schema:
      Type: AWS::AppSync::GraphQLSchema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Definition: >
              type Player {
                  PlayerName: String!
                  CodeOfConductConsent: Boolean
              }
              type Role @aws_iam @aws_cognito_user_pools {
                  RoleId: String!
                  Name: String!
                  Actions: String!
              }
              type Grant @aws_iam @aws_cognito_user_pools {
                  Resource: String!
                  Actions: String
                  Roles: String
              }
              type ResourceGrant @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  Actions: String
                  Roles: String
              }
              type ExternalGrant @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  Resource: String!
                  Actions: String
                  Roles: String
              }
              type Character @aws_iam @aws_cognito_user_pools {
                  PlayerName: String!
                  Name: String!
                  CharacterId: ID!
                  Pronouns: String
                  FirstImpression: String
                  Outfit: String
                  OneCoolThing: String
                  HomeId: String
                  Grants: [Grant]
              }
              type CharacterInPlay @aws_iam @aws_cognito_user_pools {
                  CharacterId: ID!
                  Character: Character!
                  RoomId: String!
                  ConnectionId: String
              }
              interface PermanentTreeNode {
                  PermanentId: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
              }
              type Neighborhood implements PermanentTreeNode {
                  PermanentId: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  ContextMapId: String
                  Grants: [ResourceGrant]
              }
              interface RoomPath {
                  Name: String!
                  RoomId: String
              }
              type Exit implements RoomPath {
                  Name: String!
                  RoomId: String!
                  Ancestry: String
              }
              type Entry implements RoomPath {
                  Name: String!
                  RoomId: String!
              }
              input PathInput {
                  PermanentId: String
                  Name: String!
                  RoomId: String
              }
              input ResourceGrantInput {
                CharacterId: String!
                Actions: String
                Roles: String
              }
              input ExternalGrantInput {
                CharacterId: String!
                Resource: String!
                Actions: String
                Roles: String
              }
              type Room implements PermanentTreeNode {
                  PermanentId: String!
                  Name: String!
                  Ancestry: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  Exits: [Exit]
                  Entries: [Entry]
                  Grants: [ResourceGrant]
              }
              type Message @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long!
                  Target: String!
                  Message: String!
                  RoomId: String
                  CharacterId: String
                  FromCharacterId: String
                  ToCharacterId: String
                  Recap: Boolean
                  ExpirationTime: Long
                  Type: String
                  Title: String
              }
              type PlayerSubscription @aws_iam @aws_cognito_user_pools {
                  Type: String!
                  PlayerName: String!
                  PlayerInfo: Player
                  CharacterInfo: Character
                  GrantInfo: ExternalGrant
              }
              type MapRoomEntry {
                  PermanentId: String!
                  X: Int!
                  Y: Int!
              }
              type Map @aws_iam @aws_cognito_user_pools {
                  MapId: String!
                  Name: String
                  Rooms: [MapRoomEntry]
              }
              type ChangedPermanent @aws_iam @aws_cognito_user_pools {
                Neighborhood: Neighborhood
                Room: Room
                Map: Map
              }
              input MapRoomInput {
                  PermanentId: String!
                  X: Int!
                  Y: Int!
              }
              type Mutation {
                  putPlayer(
                      PlayerName: String,
                      CodeOfConductConsent: Boolean
                    ): PlayerSubscription
                  putCharacter(
                      Name: String!,
                      CharacterId: String,
                      Pronouns: String,
                      FirstImpression: String,
                      Outfit: String,
                      OneCoolThing: String,
                      HomeId: String
                  ): PlayerSubscription
                  addCharacterInPlay(
                      CharacterId: String!
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  deleteCharacterInPlay(
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  moveCharacter(
                      CharacterId: String!
                      RoomId: String!
                  ): CharacterInPlay
                  putNeighborhood(
                      CharacterId: String!
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                      Visibility: String
                      Topology: String
                      ContextMapId: String
                      Grants: [ResourceGrantInput]
                  ): [ChangedPermanent]
                  externalPutNeighborhood(
                      PermanentId: String!
                      Name: String!
                      Ancestry: String!
                      Description: String
                      ParentId: String
                      Visibility: String
                      Topology: String
                      ContextMapId: String
                      Grants: [ResourceGrantInput]
                  ): [ChangedPermanent]
                  @aws_iam @aws_cognito_user_pools
                  putRoom(
                      PermanentId: String
                      Name: String!
                      Description: String
                      ParentId: String
                      Visibility: String
                      Topology: String
                      Exits: [PathInput]
                      Entries: [PathInput]
                  ): Room
                  externalPutRoom(
                      PermanentId: String!
                      Name: String!
                      Ancestry: String!
                      Description: String
                      ParentId: String
                      Visibility: String
                      Topology: String
                  ): [ChangedPermanent]
                  @aws_iam @aws_cognito_user_pools
                  externalUpdateGrant(
                      PlayerName: String!
                      CharacterId: String!
                      Type: String!
                      Grant: ExternalGrantInput!
                  ): PlayerSubscription
                  @aws_iam @aws_cognito_user_pools
                  putRoomMessage(
                      RoomId: String!
                      Message: String!
                      MessageType: String
                      Title: String
                      FromCharacterId: String
                      MessageId: String
                      CreatedTime: Long
                  ): Message
                  @aws_iam @aws_cognito_user_pools
                  putDirectMessage(
                      CharacterId: String!
                      Message: String!
                      FromCharacterId: String!
                      ToCharacterId: String!
                      MessageId: String
                      CreatedTime: Long
                  ): Message
                  @aws_iam @aws_cognito_user_pools
                  putRole(
                      RoleId: String!
                      Name: String!
                      Actions: String!
                  ): Role
                  @aws_iam @aws_cognito_user_pools
                  putMap(
                      MapId: String!
                      Name: String
                      Rooms: [MapRoomInput]
                  ): Map
                  @aws_iam @aws_cognito_user_pools
              }
              type Query {
                  getPlayer(PlayerName: String!): Player
                  getCharacter(playerName: String!, name: String!): Character
                  getPlayerCharacters: [Character]
                  getCharactersInPlay: [CharacterInPlay]
                  getNeighborhoodTree: [ChangedPermanent]
                  getNeighborhood(PermanentId: String!): Neighborhood
                  getRoom(PermanentId: String!): Room
                  getRoomRecap(PermanentId: String!): [Message]
                  getRoomByCharacter(CharacterId: String!): Room
                  getRoles: [Role]
                  getMaps: [Map]
              }
              type Subscription {
                  changedPlayer (PlayerName: String): PlayerSubscription
                  @aws_subscribe(mutations: ["putPlayer", "putCharacter", "externalUpdateGrant"])
                  changedCharactersInPlay: CharacterInPlay
                  @aws_subscribe(mutations: ["addCharacterInPlay", "deleteCharacterInPlay", "moveCharacter"])
                  changedPermanents: [ChangedPermanent]
                  @aws_subscribe(mutations: ["putNeighborhood", "externalPutNeighborhood", "externalPutRoom"])
                  changedRoom: Room
                  @aws_subscribe(mutations: ["putRoom"])
                  addedMessage (
                    RoomId: String
                    CharacterId: String
                  ): Message
                  @aws_subscribe(mutations: ["putRoomMessage", "putDirectMessage"])
                  changedRole : Role
                  @aws_subscribe(mutations: ["putRole"])
              }
              schema {
                  mutation: Mutation
                  query: Query
                  subscription: Subscription
              }

Outputs:
  WebSocketURI:
    Description: "The WSS Protocol URI to connect to for realtime messages"
    Value: !Join [ '', [ 'wss://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/',!Ref 'RealTimeStage'] ]

  AppSyncAPI:
    Description: The ID of the AppSync Api
    Value: !Ref AppSyncAPI

  AppSyncURL:
    Description: The URL of the AppSync GraphQL endpoint
    Value: !GetAtt AppSyncAPI.GraphQLUrl
