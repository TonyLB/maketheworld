AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  mtw-app

  SAM Template for Make The World, a serverless multiplayer text roleplaying system,
  with DynamoDB storage, React front-end and administrative tools.

Parameters:
  TablePrefix:
    Type: String
    Default: 'mtw'
    Description: (Required) The name of the new DynamoDB to store connection identifiers for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'
  PermanentsStack:
    Type: String
    Default: 'MTWPermanentsStack'
    Description: (Required) The name of the stack containing the permanents DynamoDB table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'

Resources:
  RealTimeWebSocket:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: MTWRealTimeSocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.message"
  ControlChannelPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - RealTimeWebSocket
      - ControlChannelFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ControlChannelFunction
      Principal: apigateway.amazonaws.com
  ControlChannelFunction:
    Type: AWS::Serverless::Function
    Properties:
      CodeUri: lambda/controlChannel/
      Handler: app.handler
      MemorySize: 128
      Runtime: nodejs12.x
      Layers:
        - !Ref AppSyncLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
      Policies:
        - Statement:
          - Effect: Allow
            Action:
            - 'execute-api:ManageConnections'
            Resource:
            - !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RealTimeWebSocket}/*'
        - Statement:
          - Effect: Allow
            Action: appsync:GraphQL
            Resource: !Sub '${AppSyncAPI}/*'
        - DynamoDBCrudPolicy:
              TableName: !Sub '${TablePrefix}_ephemera'
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DisconnectInteg
  DisconnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
          Fn::Sub:
              - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${ChannelArn}/invocations"
              -
                  Region: !Ref AWS::Region
                  ChannelArn: !GetAtt ControlChannelFunction.Arn
      RequestTemplates:
        application/json: >
          {
            "action": "disconnect"
          }
  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: ping
      AuthorizationType: NONE
      OperationName: PingRoute
      RouteResponseSelectionExpression: "$default"
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref PingInteg
  PingInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Ping Integration
      IntegrationType: MOCK
      PassthroughBehavior: WHEN_NO_MATCH
      TemplateSelectionExpression: "application/json"
      RequestTemplates:
        application/json: >
          {
            "statusCode": 200
          }
  PingIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref PingInteg
      TemplateSelectionExpression: "$integration.response.statuscode"
      IntegrationResponseKey: "/200/"
      ResponseTemplates:
        "200": >
          {
            "statusCode": 200,
            "type": "pong"
          }
  PingResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref PingRoute
      RouteResponseKey: "$default"
  RegisterCharacterRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: registercharacter
      AuthorizationType: NONE
      OperationName: RegisterCharacterRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref RegisterCharacterInteg
  RegisterCharacterInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Register Name Integtration
      IntegrationType: AWS_PROXY
      IntegrationUri:
          Fn::Sub:
              - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${ChannelArn}/invocations"
              -
                  Region: !Ref AWS::Region
                  ChannelArn: !GetAtt ControlChannelFunction.Arn
  RegisterCharacterIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref RegisterCharacterInteg
      IntegrationResponseKey: "/200/"
  RegisterCharacterResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref RegisterCharacterRoute
      RouteResponseKey: "$default"
  RealTimeDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
    - PingRoute
    - RegisterCharacterRoute
    - DisconnectRoute
    Properties:
      ApiId: !Ref RealTimeWebSocket
  RealTimeStage:
    Type: AWS::ApiGatewayV2::Stage
    DependsOn:
      - RealTimeDeployment
    Properties:
      StageName: Prod
      Description: Prod Stage
      DeploymentId: !Ref RealTimeDeployment
      ApiId: !Ref RealTimeWebSocket
  PermanentDeltaTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "PartitionId"
            AttributeType: "N"
          - AttributeName: "DeltaId"
            AttributeType: "S"
          - AttributeName: "RowId"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "PartitionId"
            KeyType: "HASH"
          - AttributeName: "DeltaId"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: RowIdIndex
            KeySchema:
              - AttributeName: RowId
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
        TableName: !Sub '${TablePrefix}_permanent_delta'
  EphemeraTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "EphemeraId"
            AttributeType: "S"
          - AttributeName: "DataCategory"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "EphemeraId"
            KeyType: "HASH"
          - AttributeName: "DataCategory"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: DataCategoryIndex
            KeySchema:
              - AttributeName: DataCategory
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        TableName: !Sub '${TablePrefix}_ephemera'
  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "MessageId"
        AttributeType: "S"
      - AttributeName: "DataCategory"
        AttributeType: "S"
      - AttributeName: "CreatedTime"
        AttributeType: "N"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "MessageId"
        KeyType: "HASH"
      - AttributeName: "DataCategory"
        KeyType: "RANGE"
      LocalSecondaryIndexes:
        - IndexName: CreatedTimeIndex
          KeySchema:
            - AttributeName: "MessageId"
              KeyType: "HASH"
            - AttributeName: "CreatedTime"
              KeyType: "RANGE"
          Projection:
            ProjectionType: ALL
      SSESpecification:
        SSEEnabled: False
      TableName: !Sub '${TablePrefix}_messages'
      TimeToLiveSpecification:
        AttributeName: ExpirationTime
        Enabled: True
  MessageDeltaTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "Target"
            AttributeType: "S"
          - AttributeName: "DeltaId"
            AttributeType: "S"
          - AttributeName: "RowId"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "Target"
            KeyType: "HASH"
          - AttributeName: "DeltaId"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: RowIdIndex
            KeySchema:
              - AttributeName: RowId
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
        TableName: !Sub '${TablePrefix}_message_delta'
  AppSyncLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: appsync-layer
        Description: Lambda layer to import the appsync libraries
        ContentUri: lambda/appSyncLayer/
        CompatibleRuntimes:
          - nodejs12.x
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: uuid-layer
        Description: Lambda layer to import the uuid library
        ContentUri: lambda/uuidLayer/
        CompatibleRuntimes:
          - nodejs12.x

  StorageAPIExecutionRole:
    Type: AWS::IAM::Role
    Properties:
        AssumeRolePolicyDocument:
            Statement:
              - Effect: Allow
                Principal:
                    Service: apigateway.amazonaws.com
                Action:
                    - sts:AssumeRole
        Policies:
          - PolicyName: AdminLambdaPolicy
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: "Allow"
                  Action:
                    - lambda:InvokeFunction
                  Resource:
                    - !GetAtt PermanentsFunction.Arn
          - PolicyName: StorageS3Policy
            PolicyDocument:
              Version: "2012-10-17"
              Statement:
                - Effect: "Allow"
                  Action:
                    - s3:GetObject
                  Resource:
                      Fn::Sub:
                        - "arn:aws:s3:::${StorageBucket}/*"
                        - StorageBucket:
                            Fn::ImportValue:
                              !Sub "${PermanentsStack}-StorageBucket"
  StorageApi:
    Type: 'AWS::ApiGateway::RestApi'
    Properties:
      Name: StorageApi
  BackupPathResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      ParentId: !GetAtt StorageApi.RootResourceId
      RestApiId: !Ref StorageApi
      PathPart: 'backups'
  BackupResource:
    Type: 'AWS::ApiGateway::Resource'
    Properties:
      ParentId: !Ref BackupPathResource
      RestApiId: !Ref StorageApi
      PathPart: '{PermanentId+}'
  BackupProxyMethod:
    Type: 'AWS::ApiGateway::Method'
    DependsOn:
      - BackupResource
      - StorageAPIExecutionRole
      - PermanentsFunction
    Properties:
      HttpMethod: GET
      ResourceId: !Ref BackupResource
      RestApiId: !Ref StorageApi
      ApiKeyRequired: false
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.PermanentId: true
      Integration:
        CacheKeyParameters:
          - 'method.request.path.PermanentId'
        RequestParameters:
            integration.request.path.PermanentId: 'method.request.path.PermanentId'
        IntegrationHttpMethod: GET
        Type: AWS
        Credentials: !GetAtt StorageAPIExecutionRole.Arn
        Uri:
            Fn::Sub:
                - "arn:aws:apigateway:${Region}:s3:path/${StorageBucket}/backups/{PermanentId}"
                -
                    Region: !Ref AWS::Region
                    StorageBucket:
                        Fn::ImportValue:
                            !Sub "${PermanentsStack}-StorageBucket"
        PassthroughBehavior: WHEN_NO_MATCH
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.content-disposition: "'attachment'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.content-disposition: true
  UploadBackupOptionsMethod:
    Type: 'AWS::ApiGateway::Method'
    DependsOn:
      - BackupResource
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref BackupPathResource
      RestApiId: !Ref StorageApi
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: "{ \"statusCode\": 200 }"
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              application/json: "{ \"statusCode\": 200 }"
            ResponseParameters:
              method.response.header.X-Requested-With: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-requested-with'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.X-Requested-With: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Origin: true
  UploadBackupMethod:
    Type: 'AWS::ApiGateway::Method'
    DependsOn:
      - BackupResource
      - StorageAPIExecutionRole
      - PermanentsFunction
    Properties:
      HttpMethod: POST
      ResourceId: !Ref BackupPathResource
      RestApiId: !Ref StorageApi
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.PermanentId: true
      Integration:
        RequestParameters:
            integration.request.path.PermanentId: 'method.request.path.PermanentId'
        IntegrationHttpMethod: POST
        Type: AWS
        Credentials: !GetAtt StorageAPIExecutionRole.Arn
        Uri:
            Fn::Sub:
                - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${AdminArn}/invocations"
                -
                    Region: !Ref AWS::Region
                    AdminArn: !GetAtt PermanentsFunction.Arn
        PassthroughBehavior: WHEN_NO_MATCH
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.X-Requested-With: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-requested-with'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
          - StatusCode: 500
            SelectionPattern: "Parsing error.*"
            ResponseParameters:
              method.response.header.X-Requested-With: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-requested-with'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
          - StatusCode: 400
            SelectionPattern: "Error.*"
            ResponseParameters:
              method.response.header.X-Requested-With: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,x-requested-with'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: >
              {
                "action": "uploadBackup",
                "body": $input.json('$')
              }
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.X-Requested-With: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Origin: true
        - StatusCode: 400
          ResponseParameters:
            method.response.header.X-Requested-With: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Origin: true
        - StatusCode: 500
          ResponseParameters:
            method.response.header.X-Requested-With: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Origin: true
  StorageDeployment:
      DependsOn:
        - BackupProxyMethod
        - UploadBackupMethod
        - UploadBackupOptionsMethod
      Type: 'AWS::ApiGateway::Deployment'
      Properties:
        RestApiId: !Ref StorageApi
        StageName: storage

  AppSyncAPI:
      Type: AWS::AppSync::GraphQLApi
      Properties:
          Name: !Sub ${TablePrefix}AppSyncAPI
          AuthenticationType: AMAZON_COGNITO_USER_POOLS
          UserPoolConfig:
              AwsRegion: !Ref AWS::Region
              UserPoolId:
                Fn::ImportValue:
                  !Sub "${PermanentsStack}-UserPoolId"
              DefaultAction: ALLOW
          AdditionalAuthenticationProviders:
              - AuthenticationType: AWS_IAM
  AppSyncAPIExecutionRole:
      Type: AWS::IAM::Role
      Properties:
          AssumeRolePolicyDocument:
              Statement:
                - Effect: Allow
                  Principal:
                      Service: appsync.amazonaws.com
                  Action:
                      - sts:AssumeRole
          Policies:
            - PolicyName: TablesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages"
            - PolicyName: IndexesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages/*"
            - PolicyName: AppSyncLambdasPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: Allow
                      Action: appsync:GraphQL
                      Resource: !Sub '${AppSyncAPI}/*'
                    - Effect: "Allow"
                      Action:
                          - "lambda:InvokeFunction"
                      Resource:
                        - !GetAtt PermanentsFunction.Arn
                        - !GetAtt CharactersInPlayFunction.Arn
                        - !GetAtt MessagesFunction.Arn
  PermanentsDynamoDBTableDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: Permanents
          Type: AMAZON_DYNAMODB
          ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
          DynamoDBConfig:
              AwsRegion: !Ref AWS::Region
              TableName: !Sub ${TablePrefix}_permanents
  MessagesDynamoDBTableDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        Name: Messages
        Type: AMAZON_DYNAMODB
        ServiceRoleArn: !GetAtt "AppSyncAPIExecutionRole.Arn"
        DynamoDBConfig:
            AwsRegion: !Ref AWS::Region
            TableName: !Sub ${TablePrefix}_messages
  InitializeFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/initialize/
          Handler: app.handler
          MemorySize: 128
          Runtime: nodejs12.x
          Timeout: 30
          Layers:
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  QueryGetPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: getPlayer
        DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "GetItem",
                "key": {
                    "PermanentId": $util.dynamodb.toStringJson("PLAYER#${ctx.args.PlayerName}"),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                }
            }
        ResponseMappingTemplate: >
            #set($Consent = false)
            #if ($ctx.result && $util.isBoolean($ctx.result.CodeOfConductConsent))
                #set($Consent = $ctx.result.CodeOfConductConsent)
            #end
            #set($Characters = [])
            #if ($ctx.result && $util.isList($ctx.result.Characters))
                #set($Characters = $ctx.result.Characters)
            #end
            $util.toJson({
                "PlayerName": $ctx.args.PlayerName,
                "CodeOfConductConsent": $Consent,
                "Characters": $Characters
            })
  MutationPutPlayerResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putPlayer
        DataSourceName: !GetAtt PermanentsDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            $util.qr($ctx.stash.put("PlayerName", $ctx.args.PlayerName))
            #if ($util.isNullOrEmpty($PlayerName))
              $util.qr($ctx.stash.put("PlayerName", $context.identity.username))
            #end
            #set ($Characters = [])
            #if ($ctx.args && $util.isList($ctx.args.Characters))
              #set ($Characters = $ctx.args.Characters)
            #end
            {
                "version": "2017-02-28",
                "operation": "PutItem",
                "key": {
                    "PermanentId": $util.dynamodb.toStringJson("PLAYER#${ctx.stash.PlayerName}"),
                    "DataCategory": $util.dynamodb.toStringJson("Details")
                },
                "attributeValues": {
                    "Characters": $util.dynamodb.toListJson($Characters),
                    "CodeOfConductConsent":
                      #if($ctx.args.CodeOfConductConsent)
                        $util.dynamodb.toBooleanJson($ctx.args.CodeOfConductConsent)
                      #else
                        $util.dynamodb.toBooleanJson(false)
                      #end
                }
            }
        ResponseMappingTemplate: >
          $util.toJson({
            "Type": "PLAYER",
            "PlayerName": $ctx.stash.PlayerName,
            "PlayerInfo": {
              "PlayerName": $ctx.stash.PlayerName,
              "CodeOfConductConsent": $util.defaultIfNull($ctx.result.CodeOfConductConsent, false),
              "Characters": $ctx.result.Characters
            }
          })
  QueryPlayerCharactersResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getPlayerCharacters
          DataSourceName: !GetAtt PermanentsDataSource.Name
          RequestMappingTemplate: >
              #set($arguments = {})
              $util.qr($arguments.put("PlayerName", $context.identity.username))
              $util.qr($arguments.put("action", "getPlayerCharacters"))
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": $util.toJson($arguments)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  CharactersInPlayFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/ephemera/charactersInPlay/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs12.x
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_ephemera'
            - DynamoDBReadPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
            - Statement:
                - Effect: Allow
                  Action: appsync:GraphQL
                  Resource: !Sub '${AppSyncAPI}/*'
  CharactersInPlayDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: CharactersInPlayLambda
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt CharactersInPlayFunction.Arn
  QueryGetCharactersInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getCharactersInPlay
          DataSourceName: !GetAtt CharactersInPlayDataSource.Name
          RequestMappingTemplate: >
              $util.toJson({
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "getCharactersInPlay"
                  }
              })
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  QueryGettRoomRecap:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: getRoomRecap
          DataSourceName: !GetAtt MessagesDataSource.Name
          RequestMappingTemplate: >
              $util.toJson({
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "getRoomRecap",
                    "RoomId": "$ctx.args.PermanentId"
                  }
              })
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  # QueryGetRoomRecap:
  #   Type: AWS::AppSync::Resolver
  #   DependsOn: Schema
  #   Properties:
  #       ApiId: !GetAtt AppSyncAPI.ApiId
  #       TypeName: Query
  #       FieldName: getRoomRecap
  #       DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
  #       RequestMappingTemplate: >
  #           {
  #               "version": "2017-02-28",
  #               "operation": "Query",
  #               "query": {
  #                 "expression": "Target = :RoomId",
  #                 "expressionValues": {
  #                     ":RoomId": $util.dynamodb.toDynamoDBJson("ROOM#$ctx.args.PermanentId")
  #                 }
  #               },
  #               "scanIndexForward": false,
  #               "limit": 10
  #           }
  #       ResponseMappingTemplate: >
  #           #set($output = [])
  #           #foreach($message in $ctx.result.items)
  #               #set($split = $message.DataCategory.split("#"))
  #               $util.qr($output.add({
  #                   "Target": "$ctx.result.Target",
  #                   "RoomId": "$ctx.args.PermanentId",
  #                   "Type": "$util.defaultIfNull($message.Type, 'ROOM')",
  #                   "CreatedTime": $split[0],
  #                   "MessageId": "$split[1]",
  #                   "Recap": true,
  #                   "Message": "$message.Message",
  #                   "FromCharacterId": "$util.defaultIfNull($message.FromCharacterId, '')",
  #                   "Title": "$util.defaultIfNull($message.Title, '')"
  #               }))
  #           #end
  #           $util.toJson($output)
  QuerySyncPermanentsResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Query
          FieldName: syncPermanents
          DataSourceName: !GetAtt PermanentsDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "sync"
                    #if ($ctx.args.limit)
                    , "limit": "$ctx.args.limit"
                    #end
                    #if ($ctx.args.startingAt)
                    , "startingAt": "$ctx.args.startingAt"
                    #end
                    #if ($ctx.args.exclusiveStartKey)
                    , "exclusiveStartKey": $util.toJson($ctx.args.exclusiveStartKey)
                    #end
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationAddCharacterInPlay:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: addCharacterInPlay
          DataSourceName: !GetAtt CharactersInPlayDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "putCharacterInPlay",
                    "CharacterId": $util.toJson($ctx.args.CharacterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDeleteCharacterInPlayResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: deleteCharacterInPlay
          DataSourceName: !GetAtt CharactersInPlayDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "deleteCharacterInPlay",
                    "CharacterId": $util.toJson($ctx.args.CharacterId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationDisconnectResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: disconnectCharacterInPlay
          DataSourceName: !GetAtt CharactersInPlayDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "disconnect",
                    "CharacterId": $util.toJson($ctx.args.CharacterId),
                    "ConnectionId": $util.toJson($ctx.args.ConnectionId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationMoveCharacterResolver:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: moveCharacter
          DataSourceName: !GetAtt CharactersInPlayDataSource.Name
          RequestMappingTemplate: >
              #if(!($ctx.args.CharacterId))
                  $util.error("CharacterId field required")
              #end
              #if(!($ctx.args.RoomId))
                  $util.error("RoomId field required")
              #end
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                    "action": "putCharacterInPlay",
                    "CharacterId": $util.toJson($ctx.args.CharacterId),
                    "RoomId": $util.toJson($ctx.args.RoomId)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  PermanentsFunction:
      Type: AWS::Serverless::Function
      DependsOn:
          - AppSyncAPI
      Properties:
          CodeUri: lambda/permanents/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs12.x
          Timeout: 30
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
                  S3_BUCKET:
                    Fn::ImportValue:
                      !Sub "${PermanentsStack}-StorageBucket"
          Policies:
            - Statement:
              - Effect: Allow
                Action: appsync:GraphQL
                Resource: !Sub '${AppSyncAPI}/*'
            - Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  Fn::Sub:
                      - "arn:aws:s3:::${StorageBucket}/*"
                      - StorageBucket:
                          Fn::ImportValue:
                            !Sub "${PermanentsStack}-StorageBucket"
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanent_delta'
  PermanentsDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: PermanentsLambda
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt PermanentsFunction.Arn
  MessagesFunction:
      Type: AWS::Serverless::Function
      DependsOn:
          - AppSyncAPI
      Properties:
          CodeUri: lambda/messages/
          Handler: app.handler
          MemorySize: 128
          Runtime: nodejs12.x
          Timeout: 5
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - Statement:
              - Effect: Allow
                Action: appsync:GraphQL
                Resource: !Sub '${AppSyncAPI}/*'
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_messages'
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_message_delta'
  MessagesDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: MessagesLambda
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt MessagesFunction.Arn
  NoneDataSource:
      Type: AWS::AppSync::DataSource
      DependsOn:
          - Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: NoneSource
          Type: NONE
  MutationUpdatePermanents:
      Type: AWS::AppSync::Resolver
      DependsOn:
        - Schema
        - PermanentsDataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: updatePermanents
          DataSourceName: !GetAtt PermanentsDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "action": "updatePermanents",
                      "Updates": $utils.toJson($ctx.args.Updates)
                  }
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationCreateBackup:
      Type: AWS::AppSync::Resolver
      DependsOn:
        - Schema
        - PermanentsFunction
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: createBackup
          DataSourceName: !GetAtt PermanentsDataSource.Name
          RequestMappingTemplate: >
              $util.qr($ctx.args.put("action", "createBackup"))
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": $util.toJson($ctx.args)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationRestoreBackup:
      Type: AWS::AppSync::Resolver
      DependsOn:
        - Schema
        - PermanentsFunction
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: restoreBackup
          DataSourceName: !GetAtt PermanentsDataSource.Name
          RequestMappingTemplate: >
              $util.qr($ctx.args.put("action", "restoreBackup"))
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": $util.toJson($ctx.args)
              }
          ResponseMappingTemplate: "$util.toJson($ctx.result)"
  MutationPutDirectMessage:
      Type: AWS::AppSync::Resolver
      DependsOn: Schema
      Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: putDirectMessage
        DataSourceName: !GetAtt MessagesDynamoDBTableDataSource.Name
        RequestMappingTemplate: >
            #set($args = $ctx.args)
            #if($util.isNullOrEmpty($args.CharacterId))
                $util.error("CharacterId field required")
            #end
            #set ($MessageId = $util.defaultIfNullOrBlank($args.MessageId, $util.autoId()))
            #set ($CreatedTime = $util.defaultIfNull($args.CreatedTime, $util.time.nowEpochMilliSeconds()))
            #set ($ExpirationTime = $util.time.nowEpochSeconds() + 600)
            #set( $ddb = $util.dynamodb )
            {
                "version": "2018-05-29",
                "operation": "PutItem",
                "key": {
                    "Target": $ddb.toDynamoDBJson("CHARACTER#${args.CharacterId}"),
                    "DataCategory": $ddb.toDynamoDBJson("${CreatedTime}#${MessageId}")
                },
                "attributeValues": {
                    "ExpirationTime": $ddb.toNumberJson($ExpirationTime),
                    "Recap": $ddb.toBooleanJson(false),
                    "Type": $ddb.toStringJson("DIRECT")
                    #if(!$util.isNullOrEmpty($args.Message)), "Message": $ddb.toStringJson($args.Message) #end
                    #if(!$util.isNullOrEmpty($args.FromCharacterId)), "FromCharacterId": $ddb.toStringJson($args.FromCharacterId) #end
                    #if(!$util.isNullOrEmpty($args.ToCharacterId)), "ToCharacterId": $ddb.toStringJson($args.ToCharacterId) #end
                }
            }
        ResponseMappingTemplate: >
            #set($split = $ctx.result.DataCategory.split("#"))
            {
                "Target": $util.toJson(${ctx.result.Target}),
                "CharacterId": $util.toJson(${ctx.args.CharacterId}),
                "Type": "DIRECT",
                "CreatedTime": $util.toJson($split[0]),
                "MessageId": $util.toJson($split[1]),
                "Recap": $util.toJson(false),
                "Message": $util.toJson($ctx.result.Message),
                "FromCharacterId": $util.toJson($util.defaultIfNull($ctx.result.FromCharacterId, '')),
                "ToCharacterId": $util.toJson($util.defaultIfNull($ctx.result.ToCharacterId, '')),
                "Title": $util.toJson($util.defaultIfNull($ctx.result.Title, '')),
                "RoomId": $util.toJson($util.defaultIfNull($ctx.result.RoomId, '')),
                "ExpirationTime": $util.toJson($util.defaultIfNull($ctx.result.ExpirationTime, 0))
            }
  MutationUpdateMessages:
      Type: AWS::AppSync::Resolver
      DependsOn:
        - Schema
        - MessagesDataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          TypeName: Mutation
          FieldName: updateMessages
          DataSourceName: !GetAtt MessagesDataSource.Name
          RequestMappingTemplate: >
              {
                  "version": "2017-02-28",
                  "operation": "Invoke",
                  "payload": {
                      "action": "updateMessages",
                      "Updates": $utils.toJson($ctx.args.Updates)
                  }
              }
          ResponseMappingTemplate: >
              "Updated"
  # MutationAddMessage:
  #     Type: AWS::AppSync::Resolver
  #     DependsOn:
  #       - Schema
  #       - MessagesDataSource
  #     Properties:
  #         ApiId: !GetAtt AppSyncAPI.ApiId
  #         TypeName: Mutation
  #         FieldName: addMessage
  #         DataSourceName: !GetAtt MessagesDataSource.Name
  #         RequestMappingTemplate: >
  #             {
  #                 "version": "2017-02-28",
  #                 "operation": "Invoke",
  #                 "payload": {
  #                     "action": "updateMessages",
  #                     "Updates": [ { "putMessage": $utils.toJson($ctx.args) } ]
  #                 }
  #             }
  #         ResponseMappingTemplate: >
  #             "Added"
  MutationBroadcastMessage:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: broadcastMessage
        DataSourceName: !GetAtt NoneDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "payload": $util.toJson($ctx.args.Message)
            }
        ResponseMappingTemplate: >
            $util.toJson($ctx.result)
  Schema:
      Type: AWS::AppSync::GraphQLSchema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Definition: >
              type Player {
                  PlayerName: String!
                  CodeOfConductConsent: Boolean
                  Characters: [String]
              }
              type Role @aws_iam @aws_cognito_user_pools {
                  RoleId: String!
                  Name: String!
                  Actions: String!
              }
              type Grant @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  Resource: String!
                  Actions: String
                  Roles: String
                  Revoke: Boolean
              }
              input GrantInput {
                CharacterId: String!
                Resource: String!
                Actions: String
                Roles: String
              }
              type Character @aws_iam @aws_cognito_user_pools {
                  PlayerName: String
                  Name: String!
                  CharacterId: String!
                  Pronouns: String
                  FirstImpression: String
                  Outfit: String
                  OneCoolThing: String
                  HomeId: String
              }
              type CharacterInPlay @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  RoomId: String!
                  Connected: Boolean
              }
              type Neighborhood {
                  PermanentId: String!
                  Name: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  ContextMapId: String
                  Retired: Boolean
              }
              input NeighborhoodInput {
                  PermanentId: String!
                  Name: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  ContextMapId: String
                  Retired: Boolean
              }
              type Exit {
                  FromRoomId: String!
                  ToRoomId: String!
                  Name: String
                  Delete: Boolean
              }
              input ExitInput {
                  FromRoomId: String!
                  ToRoomId: String!
                  Name: String
                  Delete: Boolean
              }
              type Room {
                  PermanentId: String!
                  Name: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  Retired: Boolean
              }
              input RoomInput @aws_iam @aws_cognito_user_pools {
                  PermanentId: String
                  Name: String!
                  Description: String
                  ParentId: String
                  Visibility: String
                  Topology: String
                  Retired: Boolean
              }
              input CharacterInput @aws_iam @aws_cognito_user_pools {
                  Name: String!,
                  CharacterId: String,
                  Pronouns: String,
                  FirstImpression: String,
                  Outfit: String,
                  OneCoolThing: String,
                  HomeId: String
              }
              type Message @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long!
                  Target: String!
                  Message: String!
                  RoomId: String
                  CharacterId: String
                  DisplayProtocol: String
                  Title: String
                  ExpirationTime: Long
                  Recipients: [String]
              }
              input MessageInput @aws_iam @aws_cognito_user_pools {
                  Target: String
                  MessageId: String!
                  Message: String!
                  CreatedTime: Long
                  RoomId: String
                  Characters: [String]
                  CharacterId: String
                  DisplayProtocol: String
                  Title: String
                  ExpirationTime: Long
                  Recipients: [String]
              }
              input MessageUpdateInput @aws_iam @aws_cognito_user_pools {
                  putMessage: MessageInput
              }
              type PlayerSubscription @aws_iam @aws_cognito_user_pools {
                  Type: String!
                  PlayerName: String!
                  PlayerInfo: Player
                  CharacterInfo: Character
                  GrantInfo: Grant
              }
              type MapRoomEntry @aws_iam @aws_cognito_user_pools {
                  PermanentId: String!
                  X: Int!
                  Y: Int!
                  Locked: Boolean
              }
              type Map @aws_iam @aws_cognito_user_pools {
                  MapId: String!
                  Name: String
                  Rooms: [MapRoomEntry]
              }
              input MapInput @aws_iam @aws_cognito_user_pools {
                  MapId: String
                  Name: String!
                  Rooms: [MapRoomInput]
              }
              type Settings @aws_iam @aws_cognito_user_pools {
                  ChatPrompt: String
              }
              input SettingsInput @aws_iam @aws_cognito_user_pools {
                  ChatPrompt: String
              }
              input MapRoomInput {
                  PermanentId: String!
                  X: Int!
                  Y: Int!
                  Locked: Boolean
              }
              type Backup @aws_iam @aws_cognito_user_pools {
                  PermanentId: String!
                  Name: String!
                  Description: String
                  Status: String
              }
              input BackupInput @aws_iam @aws_cognito_user_pools {
                  PermanentId: String
                  Name: String
                  Description: String
                  Status: String
              }
              type ChangedPermanent @aws_iam @aws_cognito_user_pools {
                Neighborhood: Neighborhood
                Room: Room
                Map: Map
                Settings: Settings
                Role: Role
                Backup: Backup
                Character: Character
                Grant: Grant
                Exit: Exit
              }
              input PermanentInput @aws_iam @aws_cognito_user_pools {
                putNeighborhood: NeighborhoodInput
                putMap: MapInput
                putSettings: SettingsInput
                putBackup: BackupInput
                putRoom: RoomInput
                putCharacter: CharacterInput
                putGrant: GrantInput
                revokeGrant: GrantInput
                putExit: ExitInput
                deleteExit: ExitInput
              }
              type LastEvaluatedKey @aws_iam @aws_cognito_user_pools {
                PermanentId: String
                DataCategory: String
              }
              input ExclusiveStartKey @aws_iam @aws_cognito_user_pools {
                PermanentId: String
                DataCategory: String
              }
              type SyncResponse @aws_iam @aws_cognito_user_pools {
                Items: [ChangedPermanent]
                LastSync: Long
                LatestMoment: Long
                LastEvaluatedKey: LastEvaluatedKey
              }
              type Mutation {
                  putPlayer(
                      PlayerName: String,
                      CodeOfConductConsent: Boolean
                      Characters: [String]
                    ): PlayerSubscription
                  addCharacterInPlay(
                      CharacterId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  deleteCharacterInPlay(
                      CharacterId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  disconnectCharacterInPlay(
                      CharacterId: String!
                      ConnectionId: String!
                  ): CharacterInPlay
                  @aws_iam @aws_cognito_user_pools
                  moveCharacter(
                      CharacterId: String!
                      RoomId: String!
                  ): CharacterInPlay
                  putDirectMessage(
                      CharacterId: String!
                      Message: String!
                      FromCharacterId: String!
                      ToCharacterId: String!
                      MessageId: String
                      CreatedTime: Long
                  ): Message
                  @aws_iam @aws_cognito_user_pools
                  updateMessages(
                      Updates: [MessageUpdateInput]
                  ): String
                  @aws_iam @aws_cognito_user_pools
                  broadcastMessage(Message: MessageInput): Message
                  @aws_iam @aws_cognito_user_pools
                  createBackup(
                      PermanentId: String
                      Name: String
                      Description: String
                  ): [ChangedPermanent]
                  @aws_iam @aws_cognito_user_pools
                  restoreBackup(
                      PermanentId: String
                  ): [ChangedPermanent]
                  @aws_iam @aws_cognito_user_pools
                  updatePermanents(
                      Updates: [PermanentInput]
                  ): [ChangedPermanent]
                  @aws_iam @aws_cognito_user_pools
              }
              type Query {
                  getPlayer(PlayerName: String!): Player
                  getPlayerCharacters: [Character]
                  getCharactersInPlay: [CharacterInPlay]
                  getRoomRecap(PermanentId: String!): [Message]
                  syncPermanents(limit: Int, exclusiveStartKey: ExclusiveStartKey, startingAt: Long): SyncResponse
              }
              type Subscription {
                  changedPlayer (PlayerName: String): PlayerSubscription
                  @aws_subscribe(mutations: ["putPlayer"])
                  changedCharactersInPlay: CharacterInPlay
                  @aws_subscribe(mutations: ["addCharacterInPlay", "deleteCharacterInPlay", "moveCharacter"])
                  changedPermanents: [ChangedPermanent]
                  @aws_subscribe(mutations: ["updatePermanents", "createBackup"])
                  addedMessage (Target: String!): Message
                  @aws_subscribe(mutations: ["broadcastMessage"])
              }
              schema {
                  mutation: Mutation
                  query: Query
                  subscription: Subscription
              }

Outputs:
  UserPoolClient:
      Description: The client ID for the player user pool
      Value:
          Fn::ImportValue:
              !Sub "${PermanentsStack}-UserPoolClient"

  UserPoolId:
      Description: The internal ID for the player user pool
      Value:
          Fn::ImportValue:
              !Sub "${PermanentsStack}-UserPoolId"

  WebSocketURI:
      Description: "The WSS Protocol URI to connect to for realtime control messages"
      Value: !Join [ '', [ 'wss://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/',!Ref 'RealTimeStage'] ]

  WebSocketApiId:
      Description: "The ID of the API for realtime controll"
      Value: !Ref RealTimeWebSocket

  StorageApiURI:
      Description: "The HTTP Protocol URI to connect to proxy to the S3 storage bucket"
      Value: !Join [ '', [ 'https://', !Ref StorageApi, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/storage'] ]

  StorageApiId:
      Description: "The ID of the API for S3 storage"
      Value: !Ref StorageApi

  AppSyncURL:
      Description: The URL of the AppSync GraphQL endpoint
      Value: !GetAtt AppSyncAPI.GraphQLUrl

  AppSyncID:
      Description: The ApiID of the AppSync GraphQL endpoint
      Value: !GetAtt AppSyncAPI.ApiId

  InitializeLambda:
      Description: The Lambda function to invoke in order to initialize the MessagesDynamoDBTableDataSource
      Value: !Ref InitializeFunction
