AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  mtw-app

  SAM Template for Make The World, a serverless multiplayer text roleplaying system,
  with DynamoDB storage, React front-end and administrative tools.

Parameters:
  TablePrefix:
    Type: String
    Default: 'mtw'
    Description: (Required) The name of the new DynamoDB to store connection identifiers for each connected clients. Minimum 3 characters
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'
  PermanentsStack:
    Type: String
    Default: 'MTWPermanentsStack'
    Description: (Required) The name of the stack containing the permanents DynamoDB table.
    MinLength: 3
    MaxLength: 50
    AllowedPattern: ^[A-Za-z_]+$
    ConstraintDescription: 'Required. Can be characters and underscore only. No numbers or special characters allowed.'

Resources:
  RealTimeWebSocket:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: MTWRealTimeSocket
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.message"
  ControlChannelPermission:
    Type: AWS::Lambda::Permission
    DependsOn:
      - ControlChannelFunction
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ControlChannelFunction
      Principal: apigateway.amazonaws.com
  ControlChannelFunction:
    Type: AWS::Serverless::Function
    Properties:
      Tracing: Active
      CodeUri: lambda/controlChannel/
      Handler: app.handler
      MemorySize: 128
      Runtime: nodejs14.x
      Timeout: 10
      Layers:
        - !Ref UUIDLambdaLayer
      Environment:
        Variables:
          TABLE_PREFIX: !Ref TablePrefix
          PERCEPTION_SERVICE: !GetAtt PerceptionFunction.Arn
          EPHEMERA_SERVICE: !GetAtt EphemeraFunction.Arn
          PERMANENTS_SERVICE: !GetAtt PermanentsFunction.Arn
          WEBSOCKET_API: !Join [ '', [ 'https://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/', 'Prod'] ]
          COGNITO_USER_POOL_CLIENT:
            Fn::ImportValue:
              !Sub "${PermanentsStack}-UserPoolClient"
          COGNITO_KEYS_URL:
            Fn::Sub:
              - "https://cognito-idp.${AWS::Region}.amazonaws.com/${CognitoUserPool}/.well-known/jwks.json"
              -
                  Region: !Ref AWS::Region
                  CognitoUserPool:
                    Fn::ImportValue:
                      !Sub "${PermanentsStack}-UserPoolId"
      Policies:
        - DynamoDBReadPolicy:
            TableName: !Sub '${TablePrefix}_permanents'
        - DynamoDBCrudPolicy:
            TableName: !Sub '${TablePrefix}_ephemera'
        - DynamoDBCrudPolicy:
            TableName: !Sub '${TablePrefix}_messages'
        - DynamoDBReadPolicy:
            TableName: !Sub '${TablePrefix}_message_delta'
        - Statement:
          - Effect: Allow
            Action:
              - lambda:InvokeFunction
            Resource:
              - !GetAtt PerceptionFunction.Arn
              - !GetAtt EphemeraFunction.Arn
              - !GetAtt PermanentsFunction.Arn
        - Statement:
          - Effect: Allow
            Action: execute-api:ManageConnections
            Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:**/@connections/*'
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DisconnectInteg
  DisconnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Disconnect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
          Fn::Sub:
              - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${ChannelArn}/invocations"
              -
                  Region: !Ref AWS::Region
                  ChannelArn: !GetAtt ControlChannelFunction.Arn
      RequestTemplates:
        application/json: >
          {
            "action": "disconnect"
          }
  #
  # TODO: Add a Lambda Authorizor on ConnectRoute, and use its output to
  # know which CognitoID is connecting the WebSocket.  Store that in association
  # with the connectionID and use that for security throughout, rather than
  # relying upon the client to send the proper userName information
  #
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref ConnectInteg
      #
      # $connect is the only WebSocket action that can take a query parameter:  We pass a JWT token
      # from Cognito to authenticate
      #
      RequestParameters:
          route.request.querystring.Authorization:
            Required: false
  ConnectInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Connect Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
          Fn::Sub:
              - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${ChannelArn}/invocations"
              -
                  Region: !Ref AWS::Region
                  ChannelArn: !GetAtt ControlChannelFunction.Arn
      RequestTemplates:
        application/json: >
          {
            "action": "connect"
          }
  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: ping
      AuthorizationType: NONE
      OperationName: PingRoute
      RouteResponseSelectionExpression: "$default"
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref PingInteg
  PingInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Ping Integration
      IntegrationType: MOCK
      PassthroughBehavior: WHEN_NO_MATCH
      TemplateSelectionExpression: "application/json"
      RequestTemplates:
        application/json: >
          {
            "statusCode": 200
          }
  PingIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref PingInteg
      TemplateSelectionExpression: "$integration.response.statuscode"
      IntegrationResponseKey: "/200/"
      ResponseTemplates:
        "200": >
          {
            "statusCode": 200,
            "type": "pong"
          }
  PingResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref PingRoute
      RouteResponseKey: "$default"
  #
  # The Route defines the mapping from a key to a particular integration.  In this case, the $default
  # key catches everything not specified explicitly
  #
  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteKey: $default
      AuthorizationType: NONE
      OperationName: DefaultRoute
      RouteResponseSelectionExpression: $default
      Target: !Join
        - '/'
        - - 'integrations'
          - !Ref DefaultInteg
  #
  # The integration connects the incoming message with a specific target.  In this case, we use
  # a direct AWS-PROXY to integrate with our lambda invocation, passing the incoming message
  # unchanged.
  #
  DefaultInteg:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref RealTimeWebSocket
      Description: Default Integration
      IntegrationType: AWS_PROXY
      IntegrationUri:
          Fn::Sub:
              - "arn:aws:apigateway:${Region}:lambda:path/2015-03-31/functions/${ChannelArn}/invocations"
              -
                  Region: !Ref AWS::Region
                  ChannelArn: !GetAtt ControlChannelFunction.Arn
  #
  # According to documentation, an IntegrationResponse shouldn't be necessary, but whenever
  # I don't include it, messaging goes wonky.  Maybe it's superstition at this point, but I'm
  # leaving it in.
  #
  DefaultIntegrationResponse:
    Type: AWS::ApiGatewayV2::IntegrationResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      IntegrationId: !Ref DefaultInteg
      IntegrationResponseKey: "/200/"
  #
  # A Response tells the Websocket to return the return-value of the NodeJS handler function as
  # a websocket message in response to the incoming data.  This isn't strictly necessary (we could
  # explicitly invoke the post-to-connection API), but it's convenient.
  #
  DefaultResponse:
    Type: AWS::ApiGatewayV2::RouteResponse
    Properties:
      ApiId: !Ref RealTimeWebSocket
      RouteId: !Ref DefaultRoute
      RouteResponseKey: "$default"
  RealTimeDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
    - PingRoute
    - ConnectRoute
    - DisconnectRoute
    - DefaultRoute
    Properties:
      ApiId: !Ref RealTimeWebSocket
  RealTimeStage:
    Type: AWS::ApiGatewayV2::Stage
    DependsOn:
      - RealTimeDeployment
    Properties:
      StageName: Prod
      Description: Prod Stage
      DeploymentId: !Ref RealTimeDeployment
      ApiId: !Ref RealTimeWebSocket
  PermanentDeltaTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "PartitionId"
            AttributeType: "N"
          - AttributeName: "DeltaId"
            AttributeType: "S"
          - AttributeName: "RowId"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "PartitionId"
            KeyType: "HASH"
          - AttributeName: "DeltaId"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: RowIdIndex
            KeySchema:
              - AttributeName: RowId
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
        TableName: !Sub '${TablePrefix}_permanent_delta'
  EphemeraTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "EphemeraId"
            AttributeType: "S"
          - AttributeName: "DataCategory"
            AttributeType: "S"
          - AttributeName: "RoomId"
            AttributeType: "S"
          - AttributeName: "ConnectionId"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "EphemeraId"
            KeyType: "HASH"
          - AttributeName: "DataCategory"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: DataCategoryIndex
            KeySchema:
              - AttributeName: DataCategory
                KeyType: HASH
              - AttributeName: EphemeraId
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: RoomIndex
            KeySchema:
              - AttributeName: RoomId
                KeyType: HASH
              - AttributeName: EphemeraId
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: ConnectionIndex
            KeySchema:
              - AttributeName: ConnectionId
                KeyType: HASH
              - AttributeName: EphemeraId
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        TableName: !Sub '${TablePrefix}_ephemera'
  MessagesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      AttributeDefinitions:
      - AttributeName: "MessageId"
        AttributeType: "S"
      - AttributeName: "DataCategory"
        AttributeType: "S"
      - AttributeName: "CreatedTime"
        AttributeType: "N"
      BillingMode: "PAY_PER_REQUEST"
      KeySchema:
      - AttributeName: "MessageId"
        KeyType: "HASH"
      - AttributeName: "DataCategory"
        KeyType: "RANGE"
      LocalSecondaryIndexes:
        - IndexName: CreatedTimeIndex
          KeySchema:
            - AttributeName: "MessageId"
              KeyType: "HASH"
            - AttributeName: "CreatedTime"
              KeyType: "RANGE"
          Projection:
            ProjectionType: ALL
      SSESpecification:
        SSEEnabled: False
      TableName: !Sub '${TablePrefix}_messages'
      TimeToLiveSpecification:
        AttributeName: ExpirationTime
        Enabled: True
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
  MessageDeltaTable:
      Type: AWS::DynamoDB::Table
      Properties:
        AttributeDefinitions:
          - AttributeName: "Target"
            AttributeType: "S"
          - AttributeName: "DeltaId"
            AttributeType: "S"
          - AttributeName: "RowId"
            AttributeType: "S"
        BillingMode: "PAY_PER_REQUEST"
        KeySchema:
          - AttributeName: "Target"
            KeyType: "HASH"
          - AttributeName: "DeltaId"
            KeyType: "RANGE"
        GlobalSecondaryIndexes:
          - IndexName: RowIdIndex
            KeySchema:
              - AttributeName: RowId
                KeyType: HASH
            Projection:
              ProjectionType: KEYS_ONLY
        TableName: !Sub '${TablePrefix}_message_delta'
  AppSyncLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: appsync-layer
        Description: Lambda layer to import the appsync libraries
        ContentUri: lambda/appSyncLayer/
        CompatibleRuntimes:
          - nodejs14.x
  UUIDLambdaLayer:
    Type: AWS::Serverless::LayerVersion
    Properties:
        LayerName: uuid-layer
        Description: Lambda layer to import the uuid library
        ContentUri: lambda/uuidLayer/
        CompatibleRuntimes:
          - nodejs14.x
  AppSyncAPI:
      Type: AWS::AppSync::GraphQLApi
      Properties:
          Name: !Sub ${TablePrefix}AppSyncAPI
          AuthenticationType: AMAZON_COGNITO_USER_POOLS
          UserPoolConfig:
              AwsRegion: !Ref AWS::Region
              UserPoolId:
                Fn::ImportValue:
                  !Sub "${PermanentsStack}-UserPoolId"
              DefaultAction: ALLOW
          AdditionalAuthenticationProviders:
              - AuthenticationType: AWS_IAM
  AppSyncAPIExecutionRole:
      Type: AWS::IAM::Role
      Properties:
          AssumeRolePolicyDocument:
              Statement:
                - Effect: Allow
                  Principal:
                      Service: appsync.amazonaws.com
                  Action:
                      - sts:AssumeRole
          Policies:
            - PolicyName: TablesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:GetItem"
                          - "dynamodb:BatchGetItem"
                          - "dynamodb:Query"
                          - "dynamodb:PutItem"
                          - "dynamodb:UpdateItem"
                          - "dynamodb:Scan"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages"
            - PolicyName: IndexesPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: "Allow"
                      Action:
                          - "dynamodb:Query"
                      Resource:
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_permanents/*"
                          - !Sub "arn:aws:dynamodb:*:*:table/${TablePrefix}_messages/*"
            - PolicyName: AppSyncLambdasPolicy
              PolicyDocument:
                  Version: "2012-10-17"
                  Statement:
                    - Effect: Allow
                      Action: appsync:GraphQL
                      Resource: !Sub '${AppSyncAPI}/*'
                    - Effect: "Allow"
                      Action:
                          - "lambda:InvokeFunction"
                      Resource:
                        - !GetAtt PermanentsFunction.Arn
                        - !GetAtt EphemeraFunction.Arn
                        - !GetAtt MessagesFunction.Arn
  InitializeFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/initialize/
          Handler: app.handler
          MemorySize: 128
          Runtime: nodejs14.x
          Timeout: 30
          Layers:
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
  EphemeraFunction:
      Type: AWS::Serverless::Function
      Properties:
          Tracing: Active
          CodeUri: lambda/ephemera/
          Timeout: 30
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs14.x
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  WEBSOCKET_API: !Join [ '', [ 'https://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/', 'Prod'] ]
          Policies:
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_ephemera'
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
            - Statement:
              - Effect: Allow
                Action: execute-api:ManageConnections
                Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:**/@connections/*'
  PermanentsFunction:
      Type: AWS::Serverless::Function
      DependsOn:
          - AppSyncAPI
      Properties:
          CodeUri: lambda/permanents/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs14.x
          Timeout: 30
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  EPHEMERA_SERVICE: !GetAtt EphemeraFunction.Arn
                  APPSYNC_ENDPOINT_URL: !GetAtt AppSyncAPI.GraphQLUrl
                  S3_BUCKET:
                    Fn::ImportValue:
                      !Sub "${PermanentsStack}-StorageBucket"
          Policies:
            - Statement:
              - Effect: Allow
                Action: appsync:GraphQL
                Resource: !Sub '${AppSyncAPI}/*'
            - Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  Fn::Sub:
                      - "arn:aws:s3:::${StorageBucket}/*"
                      - StorageBucket:
                          Fn::ImportValue:
                            !Sub "${PermanentsStack}-StorageBucket"
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanents'
            - DynamoDBCrudPolicy:
                  TableName: !Sub '${TablePrefix}_permanent_delta'
            - Statement:
              - Effect: "Allow"
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt EphemeraFunction.Arn
  AssetBucket:
      Type: AWS::S3::Bucket
      Properties:
          BucketName: !Sub '${TablePrefix}-assets'
  AssetHandlerFunction:
      Type: AWS::Serverless::Function
      Properties:
          CodeUri: lambda/assetHandler/
          Handler: app.handler
          MemorySize: 256
          Runtime: nodejs14.x
          Timeout: 30
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
                  S3_BUCKET: !Sub '${TablePrefix}-assets'
          Policies:
            - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_permanents'
            - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_ephemera'
            - Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                Resource:
                  Fn::Sub:
                      - "arn:aws:s3:::${AssetBucket}/*"
                      - AssetBucket: !Sub '${TablePrefix}-assets'
            - Statement:
              - Effect: Allow
                Action:
                  - s3:DeleteObject
                Resource:
                  Fn::Sub:
                      - "arn:aws:s3:::${AssetBucket}/upload/*"
                      - AssetBucket: !Sub '${TablePrefix}-assets'
          Events:
            BucketEvent:
              Type: S3
              Properties:
                Bucket: !Ref AssetBucket
                Filter:
                  S3Key:
                    Rules:
                      - Name: prefix
                        Value: upload/
                Events: s3:ObjectCreated:*
  MessagesFunction:
      Type: AWS::Serverless::Function
      DependsOn:
          - AppSyncAPI
      Properties:
          CodeUri: lambda/messages/
          Handler: app.handler
          MemorySize: 128
          Runtime: nodejs14.x
          Timeout: 5
          Layers:
              - !Ref UUIDLambdaLayer
              - !Ref AppSyncLambdaLayer
          Environment:
              Variables:
                  WEBSOCKET_API: !Join [ '', [ 'https://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/', 'Prod'] ]
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_messages'
            - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_message_delta'
            - DynamoDBReadPolicy:
                TableName: !Sub '${TablePrefix}_ephemera'
            - Statement:
                - Effect: Allow
                  Action: execute-api:ManageConnections
                  Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:**/@connections/*'
          Events:
            Stream:
              Type: DynamoDB
              Properties:
                Stream: !GetAtt MessagesTable.StreamArn
                BatchSize: 100
                StartingPosition: TRIM_HORIZON
  MessagesDataSource:
      Type: AWS::AppSync::DataSource
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: MessagesLambda
          Type: AWS_LAMBDA
          ServiceRoleArn: !GetAtt AppSyncAPIExecutionRole.Arn
          LambdaConfig:
              LambdaFunctionArn: !GetAtt MessagesFunction.Arn
  QuerySyncMessagesResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Query
        FieldName: syncMessages
        DataSourceName: !GetAtt MessagesDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "operation": "Invoke",
                "payload": {
                  "action": "sync"
                  #if ($ctx.args.targetId)
                  , "TargetId": "$ctx.args.targetId"
                  #end
                  #if ($ctx.args.limit)
                  , "limit": "$ctx.args.limit"
                  #end
                  #if ($ctx.args.startingAt)
                  , "startingAt": "$ctx.args.startingAt"
                  #end
                  #if ($ctx.args.exclusiveStartKey)
                  , "exclusiveStartKey": $util.toJson($ctx.args.exclusiveStartKey)
                  #end
                }
            }
        ResponseMappingTemplate: "$util.toJson($ctx.result)"
  NoneDataSource:
      Type: AWS::AppSync::DataSource
      DependsOn:
          - Schema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Name: NoneSource
          Type: NONE
  PerceptionFunction:
      Type: AWS::Serverless::Function
      Properties:
          Tracing: Active
          CodeUri: lambda/descriptionService/
          Handler: app.handler
          MemorySize: 128
          Runtime: nodejs14.x
          Timeout: 20
          Environment:
              Variables:
                  TABLE_PREFIX: !Ref TablePrefix
          Policies:
            - DynamoDBReadPolicy:
                TableName: !Sub '${TablePrefix}_permanents'
            - DynamoDBReadPolicy:
                TableName: !Sub '${TablePrefix}_ephemera'
            - DynamoDBCrudPolicy:
                TableName: !Sub '${TablePrefix}_messages'
  MutationBroadcastMessage:
    Type: AWS::AppSync::Resolver
    DependsOn:
      - Schema
    Properties:
        ApiId: !GetAtt AppSyncAPI.ApiId
        TypeName: Mutation
        FieldName: broadcastMessage
        DataSourceName: !GetAtt NoneDataSource.Name
        RequestMappingTemplate: >
            {
                "version": "2017-02-28",
                "payload": $util.toJson($ctx.args.Message)
            }
        ResponseMappingTemplate: >
            $util.toJson($ctx.result)
  Schema:
      Type: AWS::AppSync::GraphQLSchema
      Properties:
          ApiId: !GetAtt AppSyncAPI.ApiId
          Definition: >
              type WorldMessage @aws_iam @aws_cognito_user_pools {
                  Message: String!
              }
              input WorldMessageInput @aws_iam @aws_cognito_user_pools {
                  Message: String!
              }
              type CharacterMessage @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  CharacterId: String
              }
              input CharacterMessageInput @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  CharacterId: String
              }
              type DirectMessage @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  CharacterId: String
                  Title: String
                  Recipients: [String]
              }
              input DirectMessageInput @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  CharacterId: String
                  Title: String
                  Recipients: [String]
              }
              type AnnounceMessage @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  Title: String
              }
              input AnnounceMessageInput @aws_iam @aws_cognito_user_pools {
                  Message: String!
                  Title: String
              }
              type RoomDescriptionExit @aws_iam @aws_cognito_user_pools {
                  RoomId: String!
                  Name: String!
                  Visibility: String
              }
              type RoomDescriptionCharacter @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  Name: String!
                  Pronouns: String
                  FirstImpression: String
                  OneCoolThing: String
                  Outfit: String
              }
              type RoomDescription @aws_iam @aws_cognito_user_pools {
                  RoomId: String!
                  Name: String!
                  Description: String
                  Ancestry: String
                  Exits: [RoomDescriptionExit]
                  Characters: [RoomDescriptionCharacter]
              }
              input RoomDescriptionExitInput @aws_iam @aws_cognito_user_pools {
                  RoomId: String!
                  Name: String!
                  Visibility: String
              }
              input RoomDescriptionCharacterInput @aws_iam @aws_cognito_user_pools {
                  CharacterId: String!
                  Name: String!
                  Pronouns: String
                  FirstImpression: String
                  OneCoolThing: String
                  Outfit: String
              }
              input RoomDescriptionInput @aws_iam @aws_cognito_user_pools {
                  RoomId: String!
                  Name: String!
                  Description: String
                  Ancestry: String
                  Exits: [RoomDescriptionExitInput]
                  Characters: [RoomDescriptionCharacterInput]
              }
              type Message @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long!
                  ExpirationTime: Long
                  DisplayProtocol: String
                  Target: String!
                  RoomId: String
                  WorldMessage: WorldMessage
                  CharacterMessage: CharacterMessage
                  DirectMessage: DirectMessage
                  AnnounceMessage: AnnounceMessage
                  RoomDescription: RoomDescription
              }
              input MessageInput @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long
                  ExpirationTime: Long
                  DisplayProtocol: String
                  Target: String
                  RoomId: String
                  WorldMessage: WorldMessageInput
                  CharacterMessage: CharacterMessageInput
                  DirectMessage: DirectMessageInput
                  AnnounceMessage: AnnounceMessageInput
                  RoomDescription: RoomDescriptionInput
              }
              input PutMessageInput @aws_iam @aws_cognito_user_pools {
                  MessageId: String!
                  CreatedTime: Long
                  ExpirationTime: Long
                  DisplayProtocol: String
                  Characters: [String]
                  RoomId: String
                  TimeOffset: Int
                  WorldMessage: WorldMessageInput
                  CharacterMessage: CharacterMessageInput
                  DirectMessage: DirectMessageInput
                  AnnounceMessage: AnnounceMessageInput
                  RoomDescription: RoomDescriptionInput
              }
              input MessageUpdateInput @aws_iam @aws_cognito_user_pools {
                  putMessage: PutMessageInput
              }
              type MessageLastEvaluatedKey @aws_iam @aws_cognito_user_pools {
                MessageId: String
                DataCategory: String
                CreatedTime: Long
              }
              input MessageExclusiveStartKey @aws_iam @aws_cognito_user_pools {
                MessageId: String
                DataCategory: String
                CreatedTime: Long
              }
              type MessageSyncResponse @aws_iam @aws_cognito_user_pools {
                Items: [Message]
                LastEvaluatedKey: MessageLastEvaluatedKey
                LastSync: Long
              }
              type Mutation {
                  broadcastMessage(Message: MessageInput): Message
                  @aws_iam @aws_cognito_user_pools
              }
              type Query {
                  syncMessages(targetId: String, limit: Int, exclusiveStartKey: MessageExclusiveStartKey, startingAt: Long): MessageSyncResponse
              }
              type Subscription {
                  addedMessage (Target: String!): Message
                  @aws_subscribe(mutations: ["broadcastMessage"])
              }
              schema {
                  mutation: Mutation
                  query: Query
                  subscription: Subscription
              }

Outputs:
  UserPoolClient:
      Description: The client ID for the player user pool
      Value:
          Fn::ImportValue:
              !Sub "${PermanentsStack}-UserPoolClient"

  UserPoolId:
      Description: The internal ID for the player user pool
      Value:
          Fn::ImportValue:
              !Sub "${PermanentsStack}-UserPoolId"

  WebSocketURI:
      Description: "The WSS Protocol URI to connect to for realtime control messages"
      Value: !Join [ '', [ 'wss://', !Ref RealTimeWebSocket, '.execute-api.',!Ref 'AWS::Region','.amazonaws.com/',!Ref 'RealTimeStage'] ]

  WebSocketApiId:
      Description: "The ID of the API for realtime controll"
      Value: !Ref RealTimeWebSocket

  AppSyncURL:
      Description: The URL of the AppSync GraphQL endpoint
      Value: !GetAtt AppSyncAPI.GraphQLUrl

  AppSyncID:
      Description: The ApiID of the AppSync GraphQL endpoint
      Value: !GetAtt AppSyncAPI.ApiId

  InitializeLambda:
      Description: The Lambda function to invoke in order to initialize the basic world structure
      Value: !Ref InitializeFunction
